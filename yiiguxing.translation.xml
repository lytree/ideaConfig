<application>
  <component name="AppStorage">
    <option name="lastReplacementTargetLanguage" value="CHINESE" />
    <option name="newTranslationDialogWidth" value="598" />
    <option name="newTranslationDialogX" value="684" />
    <option name="newTranslationDialogY" value="440" />
    <histories>
      <item value="Indicates that the persistence provider should pick an appropriate strategy for the particular database. The &lt;code&gt;AUTO&lt;code&gt; generation strategy may expect a database resource to exist, or it may attempt to create one. A vendor may provide documentation on how to create such resources in the event that it does not support schema generation or cannot create the schema resource at runtime." />
      <item value="Indicates that the persistence provider must assign primary keys for the entity using a database sequence." />
      <item value="Indicates that the persistence provider must assign primary keys for the entity using an underlying database table to ensure uniqueness." />
      <item value="Abstract base class for auditable entities. Stores the audition values in persistent fields." />
      <item value="Intimate status" />
      <item value="Helper class used to resolve String values (either JSON Object field names or regular String values) into Java Enum instances." />
      <item value="Abbreviates a String using ellipses. This will turn &quot;Now is the time for all good men&quot; into &quot;Now is the time for...&quot;" />
      <item value="Performance testing notes (JDK 1.4, Jul03, scolebourne) Whitespace: Character.isWhitespace() is faster than WHITESPACE.indexOf() where WHITESPACE is a string of all whitespace characters Character access: String.charAt(n) versus toCharArray(), then array[n] String.charAt(n) is about 15% worse for a 10K string They are about equal for a length 50 string String.charAt(n) is about 4 times better for a length 3 string String.charAt(n) is best bet overall Append: String.concat about twice as fast as StringBuffer.append (not sure who tested this)" />
      <item value="Unwraps a given string from anther string." />
      <item value="Checks whether the given String is a UN M.49 numeric area code." />
      <item value="Checks whether the given String is a UN M.49 numeric area code. @param str the String to check @return true, is the given String is a UN M.49 numeric area code. private static boolean isNumericAreaCode(final String str) { return StringUtils.isNumeric(str) &amp;&amp; str.length() == 3; } &lt;p&gt;Obtains the list of languages supported for a given country.&lt;p&gt; &lt;p&gt;This method takes a country code and searches to find the languages available for that country. Variant locales are removed.&lt;p&gt; @param countryCode the 2 letter country code, null returns empty @return an unmodifiable List of Locale objects, not null public static List&lt;Locale&gt; languagesByCountry(final String countryCode) { if (countryCode == null) { return Collections.emptyList(); } List&lt;Locale&gt; langs = cLanguagesByCountry.get(countryCode); if (langs == null) { langs = new ArrayList&lt;&gt;(); final List&lt;Locale&gt; locales = availableLocaleList(); for (final Locale locale : locales) { if (countryCode.equals(locale.getCountry()) &amp;&amp; locale.getVariant().isEmpty()) { langs.add(locale); } } langs = Collections.unmodifiableList(langs); cLanguagesByCountry.putIfAbsent(countryCode, langs); langs = cLanguagesByCountry.get(countryCode); } return langs; } &lt;p&gt;Obtains the list of locales to search through when performing a locale search.&lt;p&gt; &lt;pre&gt; localeLookupList(Locale(&quot;fr&quot;, &quot;CA&quot;, &quot;xxx&quot;)) = [Locale(&quot;fr&quot;, &quot;CA&quot;, &quot;xxx&quot;), Locale(&quot;fr&quot;, &quot;CA&quot;), Locale(&quot;fr&quot;)] &lt;pre&gt; @param locale the locale to start from @return the unmodifiable list of Locale objects, 0 being locale, not null public static List&lt;Locale&gt; localeLookupList(final Locale locale) { return localeLookupList(locale, locale); } &lt;p&gt;Obtains the list of locales to search through when performing a locale search.&lt;p&gt; &lt;pre&gt; localeLookupList(Locale(&quot;fr&quot;, &quot;CA&quot;, &quot;xxx&quot;), Locale(&quot;en&quot;)) = [Locale(&quot;fr&quot;, &quot;CA&quot;, &quot;xxx&quot;), Locale(&quot;fr&quot;, &quot;CA&quot;), Locale(&quot;fr&quot;), Locale(&quot;en&quot;] &lt;pre&gt; &lt;p&gt;The result list begins with the most specific locale, then the next more general and so on, finishing with the default locale. The list will never contain the same locale twice.&lt;p&gt; @param locale the locale to start from, null returns empty list @param defaultLocale the default locale to use if no other is found @return the unmodifiable list of Locale objects, 0 being locale, not null public static List&lt;Locale&gt; localeLookupList(final Locale locale, final Locale defaultLocale) { final List&lt;Locale&gt; list = new ArrayList&lt;&gt;(4); if (locale != null) { list.add(locale); if (!locale.getVariant().isEmpty()) { list.add(new Locale(locale.getLanguage(), locale.getCountry())); } if (!locale.getCountry().isEmpty()) { list.add(new Locale(locale.getLanguage(), StringUtils.EMPTY)); } if (!list.contains(defaultLocale)) { list.add(defaultLocale); } } return Collections.unmodifiableList(list); } Tries to parse a locale from the given String. @param str the String to parse a locale from. @return a Locale instance parsed from the given String. @throws IllegalArgumentException if the given String can not be parsed. private static Locale parseLocale(final String str) { if (isISO639LanguageCode(str)) { return new Locale(str); } final String[] segments = str.split(&quot;_&quot;, -1); final String language = segments[0]; if (segments.length == 2) { final String country = segments[1]; if (isISO639LanguageCode(language) &amp;&amp; isISO3166CountryCode(country) || isNumericAreaCode(country)) { return new Locale(language, country); } } else if (segments.length == 3) { final String country = segments[1]; final String variant = segments[2]; if (isISO639LanguageCode(language) &amp;&amp; (country.isEmpty() || isISO3166CountryCode(country) || isNumericAreaCode(country)) &amp;&amp; !variant.isEmpty()) { return new Locale(language, country, variant); } } throw new IllegalArgumentException(&quot;Invalid locale format: &quot; + str); } Returns the given locale if non-{@code null}, otherwise {@link LocalegetDefault()}. @param locale a locale or {@code null}. @return the given locale if non-{@code null}, otherwise {@link LocalegetDefault()}. public static Locale toLocale(final Locale locale) { return locale != null ? locale : Locale.getDefault(); } &lt;p&gt;Converts a String to a Locale.&lt;p&gt; &lt;p&gt;This method takes the string format of a locale and creates the locale object from it.&lt;p&gt; &lt;pre&gt; LocaleUtils.toLocale(&quot;&quot;) = new Locale(&quot;&quot;, &quot;&quot;) LocaleUtils.toLocale(&quot;en&quot;) = new Locale(&quot;en&quot;, &quot;&quot;) LocaleUtils.toLocale(&quot;en_GB&quot;) = new Locale(&quot;en&quot;, &quot;GB&quot;) LocaleUtils.toLocale(&quot;en_001&quot;) = new Locale(&quot;en&quot;, &quot;001&quot;) LocaleUtils.toLocale(&quot;en_GB_xxx&quot;) = new Locale(&quot;en&quot;, &quot;GB&quot;, &quot;xxx&quot;) () &lt;pre&gt; &lt;p&gt;() The behavior of the JDK variant constructor changed between JDK1.3 and JDK1.4. In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't. Thus, the result from getVariant() may vary depending on your JDK.&lt;p&gt; &lt;p&gt;This method validates the input strictly. The language code must be lowercase. The country code must be uppercase. The separator must be an underscore. The length must be correct. &lt;p&gt; @param str the locale String to convert, null returns null @return a Locale, null if null input @throws IllegalArgumentException if the string is an invalid format @see LocaleforLanguageTag(String) public static Locale toLocale(final String str) { if (str == null) { return null; } if (str.isEmpty()) { LANG-941 - JDK 8 introduced an empty locale where all fields are blank return new Locale(StringUtils.EMPTY, StringUtils.EMPTY); } if (str.contains(&quot;&quot;)) { LANG-879 - Cannot handle Java 7 script &amp; extensions throw new IllegalArgumentException(&quot;Invalid locale format: &quot; + str); } final int len = str.length(); if (len &lt; 2) { throw new IllegalArgumentException(&quot;Invalid locale format: &quot; + str); } final char ch0 = str.charAt(0); if (ch0 == '_') { if (len &lt; 3) { throw new IllegalArgumentException(&quot;Invalid locale format: &quot; + str); } final char ch1 = str.charAt(1); final char ch2 = str.charAt(2); if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { throw new IllegalArgumentException(&quot;Invalid locale format: &quot; + str); } if (len == 3) { return new Locale(StringUtils.EMPTY, str.substring(1, 3)); } if (len &lt; 5) { throw new IllegalArgumentException(&quot;Invalid locale format: &quot; + str); } if (str.charAt(3) != '_') { throw new IllegalArgumentException(&quot;Invalid locale format: &quot; + str); } return new Locale(StringUtils.EMPTY, str.substring(1, 3), str.substring(4)); } return parseLocale(str); } &lt;p&gt;{@code LocaleUtils} instances should NOT be constructed in standard programming. Instead, the class should be used as {@code LocaleUtils.toLocale(&quot;en_GB&quot;);}.&lt;p&gt; &lt;p&gt;This constructor is public to permit tools that require a JavaBean instance to operate.&lt;p&gt;" />
      <item value="if the given String is a ISO 639 compliant language code." />
      <item value="Checks whether the given String is a ISO 639 compliant language code." />
      <item value="is the given String is a ISO 3166 compliant country code." />
      <item value="the String to check" />
      <item value="Checks whether the given String is a ISO 3166 alpha-2 country code." />
      <item value="true if the locale is a known locale" />
      <item value="the Locale object to check if it is available" />
      <item value="Checks if the locale specified is in the list of available locales." />
      <item value="an unmodifiable List of Locale objects, not null" />
      <item value="the 2 letter language code, null returns empty" />
      <item value="This method takes a language code and searches to find the countries available for that language. Variant locales are removed." />
      <item value="Obtains the list of countries supported for a given language." />
      <item value="the unmodifiable set of available locales" />
      <item value="his method is a wrapper around {@link LocalegetAvailableLocales()}. It is more efficient, as the JDK method must create a new array each time it is called." />
      <item value="Obtains an unmodifiable set of installed locales." />
      <item value="&lt;p&gt;Obtains an unmodifiable list of installed locales.&lt;p&gt; &lt;p&gt;This method is a wrapper around {@link LocalegetAvailableLocales()}. It is more efficient, as the JDK method must create a new array each time it is called.&lt;p&gt; @return the unmodifiable list of available locales" />
      <item value="Concurrent map of country locales by language." />
      <item value="Concurrent map of language locales by country." />
      <item value="Unmodifiable set of available locales." />
      <item value="Unmodifiable list of available locales." />
      <item value="&lt;p&gt;Operations to assist when working with a {@link Locale}.&lt;p&gt; &lt;p&gt;This class tries to handle {@code null} input gracefully. An exception will not be thrown for a {@code null} input. Each method documents its behavior in more detail.&lt;p&gt;" />
      <item value="Recycle status." />
      <item value="Original content,not format." />
      <item value="Deprecated use the Little Endian accessors, e.g. getShortLE, getIntLE instead of creating a buffer with swapped endianness." />
      <item value="A channel that sends Messages to each of its subscribers. Author: Mark Fisher, Oleg Zhurakousky, Gary Russell, Artem Bilan, Trung Pham" />
      <item value="Simple contract for handling a Message." />
      <item value="Defines methods for sending messages." />
      <item value="A message implementation that is produced by an advice after successful message handling. Contains the result of the expression evaluation in the payload and the original message that the advice passed to the handler." />
      <item value="ChannelOutboundHandlerAdapter which encodes message in a stream-like fashion from one message to an ByteBuf. Example implementation which encodes Integers to a ByteBuf. public class IntegerEncoder extends MessageToByteEncoder&lt;Integer&gt; { @Override public void encode(ChannelHandlerContext ctx, Integer msg, ByteBuf out) throws Exception { out.writeInt(msg); } }" />
      <item value="An encoder that prepends the length of the message. The length value is prepended as a binary form. For example, LengthFieldPrepender(2) will encode the following 12-bytes string: +----------------+ | &quot;HELLO, WORLD&quot; | +----------------+ into the following: +--------+----------------+ + 0x000C | &quot;HELLO, WORLD&quot; | +--------+----------------+ If you turned on the lengthIncludesLengthFieldLength flag in the constructor, the encoded data would look like the following (12 (original data) + 2 (prepended data) = 14 (0xE)): +--------+----------------+ + 0x000E | &quot;HELLO, WORLD&quot; | +--------+----------------+" />
      <item value="daemon" />
      <item value="The method {@link setScale(int, RoundingMode)} should be used in preference to this legacy method." />
      <item value="Returns a {@code BigDecimal} whose scale is the specified value, and whose unscaled value is determined by multiplying or dividing this {@code BigDecimal}'s unscaled value by the appropriate power of ten to maintain its overall value. If the scale is reduced by the operation, the unscaled value must be divided (rather than multiplied), and the value may be changed; in this case, the specified rounding mode is applied to the division. @apiNote Since BigDecimal objects are immutable, calls of this method do &lt;em&gt;not&lt;em&gt; result in the original object being modified, contrary to the usual convention of having methods named &lt;code&gt;set&lt;i&gt;X&lt;i&gt;&lt;code&gt; mutate field &lt;i&gt;{@code X}&lt;i&gt;. Instead, {@code setScale} returns an object with the proper scale; the returned object may or may not be newly allocated. @deprecated The method {@link setScale(int, RoundingMode)} should be used in preference to this legacy method. @param newScale scale of the {@code BigDecimal} value to be returned. @param roundingMode The rounding mode to apply. @return a {@code BigDecimal} whose scale is the specified value, and whose unscaled value is determined by multiplying or dividing this {@code BigDecimal}'s unscaled value by the appropriate power of ten to maintain its overall value. @throws ArithmeticException if {@code roundingMode==ROUND_UNNECESSARY} and the specified scaling operation would require rounding. @throws IllegalArgumentException if {@code roundingMode} does not represent a valid rounding mode. @see ROUND_UP @see ROUND_DOWN @see ROUND_CEILING @see ROUND_FLOOR @see ROUND_HALF_UP @see ROUND_HALF_DOWN @see ROUND_HALF_EVEN @see ROUND_UNNECESSARY" />
      <item value="The annotated element must be {@code null}. Accepts any type." />
      <item value="Returns the minimum value in an array." />
      <item value="the minimum value in the array" />
      <item value="an array, must not be null or empty" />
      <item value="Provides IEEE-754r variants of NumberUtils methods." />
      <item value="Provides extra functionality for Java Number classes." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="212" />
        <entry key="ENGLISH" value="208" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1659942262620" />
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20190412000287251" />
      </app-key>
    </option>
    <option name="phoneticFontFamily" value="Source Code Pro Medium" />
    <option name="primaryFontFamily" value="Microsoft YaHei UI" />
    <option name="showReplacementActionInContextMenu" value="true" />
    <option name="targetLanguageSelection" value="PRIMARY_LANGUAGE" />
    <option name="translateDocumentation" value="true" />
    <option name="translator" value="YOUDAO" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="3289501515931655" />
        <option name="primaryLanguage" value="CHINESE" />
      </youdao-translate>
    </option>
  </component>
</application>