<application>
  <component name="AppStorage">
    <histories>
      <item value="Returns {@code true} iff &lt;i&gt;a&lt;i&gt; is a sub-collection of &lt;i&gt;b&lt;i&gt;, that is, iff the cardinality of &lt;i&gt;e&lt;i&gt; in &lt;i&gt;a&lt;i&gt; is less than or equal to the cardinality of &lt;i&gt;e&lt;i&gt; in &lt;i&gt;b&lt;i&gt;, for each element &lt;i&gt;e&lt;i&gt; in &lt;i&gt;a&lt;i&gt;. @param a the first (sub?) collection, must not be null @param b the second (super?) collection, must not be null @return {@code true} iff &lt;i&gt;a&lt;i&gt; is a sub-collection of &lt;i&gt;b&lt;i&gt; @throws NullPointerException if either collection is null @see isProperSubCollection @see CollectioncontainsAll" />
      <item value="@return The category of the constructed Logger. By default, it will use the type where the annotation is placed." />
      <item value="Handles any &lt;code&gt;AccessDeniedException&lt;code&gt; and &lt;code&gt;AuthenticationException&lt;code&gt; thrown within the filter chain. &lt;p&gt; This filter is necessary because it provides the bridge between Java exceptions and HTTP responses. It is solely concerned with maintaining the user interface. This filter does not do any actual security enforcement. &lt;p&gt; If an {@link AuthenticationException} is detected, the filter will launch the &lt;code&gt;authenticationEntryPoint&lt;code&gt;. This allows common handling of authentication failures originating from any subclass of {@link org.springframework.security.access.intercept.AbstractSecurityInterceptor}. &lt;p&gt; If an {@link AccessDeniedException} is detected, the filter will determine whether or not the user is an anonymous user. If they are an anonymous user, the &lt;code&gt;authenticationEntryPoint&lt;code&gt; will be launched. If they are not an anonymous user, the filter will delegate to the {@link org.springframework.security.web.access.AccessDeniedHandler}. By default the filter will use {@link org.springframework.security.web.access.AccessDeniedHandlerImpl}. &lt;p&gt; To use this filter, it is necessary to specify the following properties: &lt;ul&gt; &lt;li&gt;&lt;code&gt;authenticationEntryPoint&lt;code&gt; indicates the handler that should commence the authentication process if an &lt;code&gt;AuthenticationException&lt;code&gt; is detected. Note that this may also switch the current protocol from http to https for an SSL login.&lt;li&gt; &lt;li&gt;&lt;tt&gt;requestCache&lt;tt&gt; determines the strategy used to save a request during the authentication process in order that it may be retrieved and reused once the user has authenticated. The default implementation is {@link HttpSessionRequestCache}.&lt;li&gt; &lt;ul&gt; @author Ben Alex @author colin sampaleanu" />
      <item value="Provides a convenient base class for creating a {@link WebSecurityConfigurer} instance. The implementation allows customization by overriding methods. &lt;p&gt; Will automatically apply the result of looking up {@link AbstractHttpConfigurer} from {@link SpringFactoriesLoader} to allow developers to extend the defaults. To do this, you must create a class that extends AbstractHttpConfigurer and then create a file in the classpath at &quot;META-INFspring.factories&quot; that looks something like: &lt;p&gt; &lt;pre&gt; org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer = sample.MyClassThatExtendsAbstractHttpConfigurer &lt;pre&gt; If you have multiple classes that should be added you can use &quot;,&quot; to separate the values. For example: &lt;pre&gt; org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer = sample.MyClassThatExtendsAbstractHttpConfigurer, sample.OtherThatExtendsAbstractHttpConfigurer &lt;pre&gt; @author Rob Winch @see EnableWebSecurity" />
      <item value="Abstract processor of browser-based HTTP-based authentication requests. &lt;h3&gt;Authentication Process&lt;h3&gt; The filter requires that you set the &lt;tt&gt;authenticationManager&lt;tt&gt; property. An &lt;tt&gt;AuthenticationManager&lt;tt&gt; is required to process the authentication request tokens created by implementing classes. &lt;p&gt; This filter will intercept a request and attempt to perform authentication from that request if the request matches the {@link setRequiresAuthenticationRequestMatcher(RequestMatcher)}. &lt;p&gt; Authentication is performed by the {@link attemptAuthentication(HttpServletRequest, HttpServletResponse) attemptAuthentication} method, which must be implemented by subclasses. &lt;h4&gt;Authentication Success&lt;h4&gt; If authentication is successful, the resulting {@link Authentication} object will be placed into the &lt;code&gt;SecurityContext&lt;code&gt; for the current thread, which is guaranteed to have already been created by an earlier filter. &lt;p&gt; The configured {@link setAuthenticationSuccessHandler(AuthenticationSuccessHandler) AuthenticationSuccessHandler} will then be called to take the redirect to the appropriate destination after a successful login. The default behaviour is implemented in a {@link SavedRequestAwareAuthenticationSuccessHandler} which will make use of any &lt;tt&gt;DefaultSavedRequest&lt;tt&gt; set by the &lt;tt&gt;ExceptionTranslationFilter&lt;tt&gt; and redirect the user to the URL contained therein. Otherwise it will redirect to the webapp root &quot;&quot;. You can customize this behaviour by injecting a differently configured instance of this class, or by using a different implementation. &lt;p&gt; See the {@link successfulAuthentication(HttpServletRequest, HttpServletResponse, FilterChain, Authentication)} method for more information. &lt;h4&gt;Authentication Failure&lt;h4&gt; If authentication fails, it will delegate to the configured {@link AuthenticationFailureHandler} to allow the failure information to be conveyed to the client. The default implementation is {@link SimpleUrlAuthenticationFailureHandler} , which sends a 401 error code to the client. It may also be configured with a failure URL as an alternative. Again you can inject whatever behaviour you require here. &lt;h4&gt;Event Publication&lt;h4&gt; If authentication is successful, an {@link InteractiveAuthenticationSuccessEvent} will be published via the application context. No events will be published if authentication was unsuccessful, because this would generally be recorded via an {@code AuthenticationManager}-specific application event. &lt;h4&gt;Session Authentication&lt;h4&gt; The class has an optional {@link SessionAuthenticationStrategy} which will be invoked immediately after a successful call to {@code attemptAuthentication()}. Different implementations {@link setSessionAuthenticationStrategy(SessionAuthenticationStrategy) can be injected} to enable things like session-fixation attack prevention or to control the number of simultaneous sessions a principal may have. @author Ben Alex @author Luke Taylor" />
      <item value="An {@link AccessDeniedHandler} that delegates to other {@link AccessDeniedHandler} instances based upon the type of {@link HttpServletRequest} passed into {@link handle(HttpServletRequest, HttpServletResponse, AccessDeniedException)}. @author Josh Cummings @since 5.1" />
      <item value="Handles an access denied failure. @param request that resulted in an &lt;code&gt;AccessDeniedException&lt;code&gt; @param response so that the user agent can be advised of the failure @param accessDeniedException that caused the invocation @throws IOException in the event of an IOException @throws ServletException in the event of a ServletException" />
      <item value="Access Denied Exception" />
      <item value="Adds HTTP basic based authentication. All attributes have reasonable defaults making all parameters are optional. &lt;h2&gt;Security Filters&lt;h2&gt; The following Filters are populated &lt;ul&gt; &lt;li&gt;{@link BasicAuthenticationFilter}&lt;li&gt; &lt;ul&gt; &lt;h2&gt;Shared Objects Created&lt;h2&gt; &lt;ul&gt; &lt;li&gt;AuthenticationEntryPoint - populated with the {@link authenticationEntryPoint(AuthenticationEntryPoint)} (default {@link BasicAuthenticationEntryPoint})&lt;li&gt; &lt;ul&gt; &lt;h2&gt;Shared Objects Used&lt;h2&gt; The following shared objects are used: &lt;ul&gt; &lt;li&gt;{@link AuthenticationManager}&lt;li&gt; &lt;li&gt;{@link RememberMeServices}&lt;li&gt; &lt;ul&gt; @author Rob Winch @since 3.2" />
      <item value="If &quot;authenticate&quot; was passed to this method it update the defaults as shown below: &lt;ul&gt; &lt;li&gt;authenticate GET - the login form&lt;li&gt; &lt;li&gt;authenticate POST - process the credentials and if valid authenticate the user &lt;li&gt; &lt;li&gt;authenticate?error GET - redirect here for failed authentication attempts&lt;li&gt; &lt;li&gt;authenticate?logout GET - redirect here after successfully logging out&lt;li&gt; &lt;ul&gt; @param loginPage the login page to redirect to if authentication is required (i.e. &quot;login&quot;) @return the {@link FormLoginConfigurer} for additional customization" />
      <item value="Specifies the URL to validate the credentials. @param loginProcessingUrl the URL to validate username and password @return the {@link FormLoginConfigurer} for additional customization" />
      <item value="The example below demonstrates how to configure HTTP Basic authentication for an application. The default realm is &quot;Realm&quot;, but can be customized using" />
      <item value="Bearer Token Access Denied Handler" />
      <item value="Spring Security will never create an {@link HttpSession} and it will never use it to obtain the {@link SecurityContext}" />
      <item value="Create an expression that tests whether its argument are equal, returning null if they are and the value of the first expression if they are not. @param x expression @param y value @return nullif expression" />
      <item value="Find a single {@link Annotation} of {@code annotationType} on the supplied {@link Class}, traversing its interfaces, annotations, and superclasses if the annotation is not &lt;em&gt;directly present&lt;em&gt; on the given class itself. &lt;p&gt;This method explicitly handles class-level annotations which are not declared as {@link java.lang.annotation.Inherited inherited} &lt;em&gt;as well as meta-annotations and annotations on interfaces&lt;em&gt;. &lt;p&gt;The algorithm operates as follows: &lt;ol&gt; &lt;li&gt;Search for the annotation on the given class and return it if found. &lt;li&gt;Recursively search through all annotations that the given class declares. &lt;li&gt;Recursively search through all interfaces that the given class declares. &lt;li&gt;Recursively search through the superclass hierarchy of the given class. &lt;ol&gt; &lt;p&gt;Note: in this context, the term &lt;em&gt;recursively&lt;em&gt; means that the search process continues by returning to step 1 with the current interface, annotation, or superclass as the class to look for annotations on. @param clazz the class to look for annotations on @param annotationType the type of annotation to look for @return the first matching annotation, or {@code null} if not found" />
      <item value="Get a single {@link Annotation} of {@code annotationType} from the supplied annotation: either the given annotation itself or a direct meta-annotation thereof. &lt;p&gt;Note that this method supports only a single level of meta-annotations. For support for arbitrary levels of meta-annotations, use one of the {@code find()} methods instead. @param annotation the Annotation to check @param annotationType the annotation type to look for, both locally and as a meta-annotation @return the first matching annotation, or {@code null} if not found @since 4.0" />
      <item value="Attribute converter persistence unit post processor." />
      <item value="Find whether the parent category is encrypted. If it is found, the result will be returned immediately. Otherwise, it will be found recursively according to parentId." />
      <item value="One or more properties of the result type on which the mapped property depends. The generated method implementation will invoke the setters of the result type ordered so that the given dependency relationship(s) are satisfied. Useful in case one property setter depends on the state of another property of the result type. &lt;p&gt; An error will be raised in case a cycle in the dependency relationships is detected. @return the dependencies of the mapped property" />
      <item value="A qualifier can be specified to aid the selection process of a suitable mapper. This is useful in case multiple mapping methods (hand written or generated) qualify and thus would result in an 'Ambiguous mapping methods found' error. A qualifier is a custom annotation and can be placed on a hand written mapper class or a method. @return the qualifiers" />
      <item value="A qualifier can be specified to aid the selection process of a suitable mapper. This is useful in case multiple mapping methods (hand written or generated) qualify and thus would result in an 'Ambiguous mapping methods found' error. A qualifier is a custom annotation and can be placed on a hand written mapper class or a method. @return the qualifiers @see Qualifier" />
      <item value="Get post with the latest content by id. content from patch log." />
      <item value="The actual content of the post obtained by applying patch to V1 version." />
      <item value="Shifts the order of the given float array." />
      <item value="andomly permutes the elements of the specified array using the Fisher-Yates algorithm." />
      <item value="&lt;p&gt;Produces a new {@code boolean} array containing the elements between the start and end indices. &lt;p&gt;The start index is inclusive, the end index exclusive. Null array input produces null output." />
      <item value="Reverses the order of the given array in the given range." />
      <item value="Gets an array containing the sole value of {@link Object} if {@link WildcardTypegetUpperBounds()} returns an empty array. Otherwise, it returns the result of {@link WildcardTypegetUpperBounds()} passed into {@link normalizeUpperBounds}. @param wildcardType the subject wildcard type, not {@code null} @return a non-empty array containing the upper bounds of the wildcard type." />
      <item value="Gets an array containing the sole value of {@link Object} if {@link WildcardTypegetUpperBounds()} returns an empty array. Otherwise, it returns the result of {@link WildcardTypegetUpperBounds()} passed into {@link normalizeUpperBounds}." />
      <item value="This class implements the {@code Map} interface with a hash table, using reference-equality in place of object-equality when comparing keys (and values). In other words, in an {@code IdentityHashMap}, two keys {@code k1} and {@code k2} are considered equal if and only if {@code (k1==k2)}. (In normal {@code Map} implementations (like {@code HashMap}) two keys {@code k1} and {@code k2} are considered equal if and only if {@code (k1==null ? k2==null : k1.equals(k2))}.) &lt;p&gt;&lt;b&gt;This class is &lt;i&gt;not&lt;i&gt; a general-purpose {@code Map} implementation! While this class implements the {@code Map} interface, it intentionally violates {@code Map's} general contract, which mandates the use of the {@code equals} method when comparing objects. This class is designed for use only in the rare cases wherein reference-equality semantics are required.&lt;b&gt; &lt;p&gt;A typical use of this class is &lt;i&gt;topology-preserving object graph transformations&lt;i&gt;, such as serialization or deep-copying. To perform such a transformation, a program must maintain a &quot;node table&quot; that keeps track of all the object references that have already been processed. The node table must not equate distinct objects even if they happen to be equal. Another typical use of this class is to maintain &lt;i&gt;proxy objects&lt;i&gt;. For example, a debugging facility might wish to maintain a proxy object for each object in the program being debugged. &lt;p&gt;This class provides all of the optional map operations, and permits {@code null} values and the {@code null} key. This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time." />
      <item value="Set properties with method names as keys and transaction attribute descriptors (parsed via TransactionAttributeEditor) as values: e.g. key = &quot;myMethod&quot;, value = &quot;PROPAGATION_REQUIRED,readOnly&quot;. &lt;p&gt;Note: Method names are always applied to the target class, no matter if defined in an interface or the class itself. &lt;p&gt;Internally, a NameMatchTransactionAttributeSource will be created from the given properties." />
      <item value="hash for forwarding nodes" />
      <item value="The smallest table capacity for which bins may be treeified. (Otherwise the table is resized if too many nodes in a bin.) The value should be at least 4 TREEIFY_THRESHOLD to avoid conflicts between resizing and treeification thresholds." />
      <item value="Handling edge case: Joda-time can only handle up to year 292278993 but we are given 292278994; So we parse the date string by first adjusting the year to 292278993. Then we add 1 year back afterwards." />
      <item value="Returns the read limit for mark-and-reset during retries; or -1 if not available." />
      <item value="It is highly recommended to fix these problems because they threaten the stability of your build. For this reason, future Maven versions might no longer support building such malformed projects." />
      <item value="allow Circular References" />
      <item value="Eagerly caching bean 'linkMapper' to allow for resolving potential circular references" />
      <item value="is Singleton Currently In Creation" />
      <item value="Eagerly cache singletons to be able to resolve circular references even when triggered by lifecycle interfaces like BeanFactoryAware." />
      <item value="Add the given singleton factory for building the specified singleton if necessary. To be called for eager registration of singletons, e.g. to be able to resolve circular references. Params: beanName – the name of the bean singletonFactory – the factory for the singleton object" />
      <item value="Simple implementation of the {@link ApplicationEventMulticaster} interface. &lt;p&gt;Multicasts all events to all registered listeners, leaving it up to the listeners to ignore events that they are not interested in. Listeners will usually perform corresponding {@code instanceof} checks on the passed-in event object. &lt;p&gt;By default, all listeners are invoked in the calling thread. This allows the danger of a rogue listener blocking the entire application, but adds minimal overhead. Specify an alternative task executor to have listeners executed in different threads, for example from a thread pool." />
      <item value="Propagate refresh to lifecycle processor first." />
      <item value="{@link BeanFactoryPostProcessor} used for bootstrapping processing of {@link Configuration @Configuration} classes. &lt;p&gt;Registered by default when using {@code &lt;context:annotation-config&gt;} or {@code &lt;context:component-scan&gt;}. Otherwise, may be declared manually as with any other {@link BeanFactoryPostProcessor}. &lt;p&gt;This post processor is priority-ordered as it is important that any {@link Bean @Bean} methods declared in {@code @Configuration} classes have their corresponding bean definitions registered before any other {@code BeanFactoryPostProcessor} executes." />
      <item value="registry Processors" />
      <item value="regular Post Processors" />
      <item value="Tell the subclass to refresh the internal bean factory." />
      <item value="Flag that indicates whether this context has been closed already." />
      <item value="Step recording metrics about a particular phase or action happening during the {@link ApplicationStartup}. &lt;p&gt;The lifecycle of a {@code StartupStep} goes as follows: &lt;ol&gt; &lt;li&gt;the step is created and starts by calling {@link ApplicationStartupstart(String) the application startup} and is assigned a unique {@link StartupStepgetId() id}. &lt;li&gt;we can then attach information with {@link Tags} during processing &lt;li&gt;we then need to mark the {@link end()} of the step &lt;ol&gt; &lt;p&gt;Implementations can track the &quot;execution time&quot; or other metrics for steps." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="58" />
        <entry key="ENGLISH" value="58" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1654751802548" />
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20190412000287251" />
      </app-key>
    </option>
    <option name="phoneticFontFamily" value="Source Code Pro Medium" />
    <option name="primaryFontFamily" value="Microsoft YaHei UI" />
    <option name="translateDocumentation" value="true" />
    <option name="translator" value="YOUDAO" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="3289501515931655" />
      </youdao-translate>
    </option>
  </component>
</application>