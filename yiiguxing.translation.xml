<application>
  <component name="AppStorage">
    <histories>
      <item value="the separator character to use, null treated as &quot;&quot;" />
      <item value="&lt;p&gt;Joins the elements of the provided array into a single String containing the provided list of elements.&lt;p&gt; &lt;p&gt;No delimiter is added before or after the list. A {@code null} separator is the same as an empty String (&quot;&quot;). Null objects or empty strings within the array are represented by empty strings.&lt;p&gt; &lt;pre&gt; StringUtils.join(null, ) = null StringUtils.join([], ) = &quot;&quot; StringUtils.join([null], ) = &quot;&quot; StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;--&quot;) = &quot;a--b--c&quot; StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], null) = &quot;abc&quot; StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;&quot;) = &quot;abc&quot; StringUtils.join([null, &quot;&quot;, &quot;a&quot;], ',') = &quot;,,a&quot; &lt;pre&gt; @param array the array of values to join together, may be null @param delimiter the separator character to use, null treated as &quot;&quot; @return the joined String, {@code null} if null array input" />
      <item value="Gets the contents of an {@code InputStream} as a {@code byte[]}. &lt;p&gt; This method buffers the input internally, so there is no need to use a {@code BufferedInputStream}. &lt;p&gt; @param inputStream the {@code InputStream} to read. @return the requested byte array. @throws NullPointerException if the InputStream is {@code null}. @throws IOException if an IO error occurs or reading more than {@link IntegerMAX_VALUE} occurs." />
      <item value="An output stream which triggers an event when a specified number of bytes of data have been written to it. The event can be used, for example, to throw an exception if a maximum has been reached, or to switch the underlying stream type when the threshold is exceeded. &lt;p&gt; This class overrides all {@code OutputStream} methods. However, these overrides ultimately call the corresponding methods in the underlying output stream implementation. &lt;p&gt; &lt;p&gt; NOTE: This implementation may trigger the event &lt;em&gt;before&lt;em&gt; the threshold is actually reached, since it triggers when a pending write operation would cause the threshold to be exceeded. &lt;p&gt;" />
      <item value="Abstract class for writing filtered character streams to a {@link Collection} of writers. This is in contrast to {@link FilterWriter} which is backed by a single {@link Writer}. &lt;p&gt; This abstract class provides default methods that pass all requests to the contained writers. Subclasses should likely override some of these methods. &lt;p&gt; &lt;p&gt; The class {@link Writer} defines method signatures with {@code throws} {@link IOException}, which in this class are actually {@link IOExceptionList} containing a list of {@link IOIndexedException}. &lt;p&gt; @since 2.7" />
      <item value="Forwards data to a stream that has been associated with this thread." />
      <item value="An {@link InputStream} that utilizes memory mapped files to improve performance. A sliding window of the file is mapped to memory to avoid mapping the entire file to memory at one time. The size of the sliding buffer is configurable. &lt;p&gt; For most operating systems, mapping a file into memory is more expensive than reading or writing a few tens of kilobytes of data. From the standpoint of performance. it is generally only worth mapping relatively large files into memory. &lt;p&gt; &lt;p&gt; Note: Use of this class does not necessarily obviate the need to use a {@link BufferedInputStream}. Depending on the use case, the use of buffering may still further improve performance. For example: &lt;p&gt; &lt;pre&gt; new BufferedInputStream(new GzipInputStream(new MemoryMappedFileInputStream(path)))) &lt;pre&gt; &lt;p&gt; should outperform: &lt;p&gt; &lt;pre&gt; new GzipInputStream(new MemoryMappedFileInputStream(path)) &lt;pre&gt; @since 2.12.0" />
      <item value="This is an alternative to {@link java.io.ByteArrayInputStream} which removes the synchronization overhead for non-concurrent access; as such this class is not thread-safe. Proxy stream that prevents the underlying input stream from being markedreset. &lt;p&gt; This class is typically used in cases where an input stream that supports marking needs to be passed to a component that wants to explicitly mark the stream, but it it is not desirable to allow marking of the stream. &lt;p&gt; @since 2.8.0" />
      <item value="Data written to this stream is forwarded to a stream that has been associated with this thread." />
      <item value="Streams data from a {@link RandomAccessFile} starting at its current position. @since 2.8.0" />
      <item value="TODO Consider making this public and use from LineIterator but this feels like it belongs in LANG rather than IO. &lt;" />
      <item value="A special ObjectInputStream that loads a class based on a specified {@code ClassLoader} rather than the system default. &lt;p&gt; This is useful in dynamic container environments. &lt;p&gt; @since 1.1" />
      <item value="Cleans a direct {@link ByteBuffer}. Without manual intervention, direct ByteBuffers will be cleaned eventually upon garbage collection. However, this should not be be relied upon since it may not occur in a timely fashion - especially since off heap ByeBuffers don't put pressure on the garbage collector. &lt;p&gt; &lt;b&gt;Warning:&lt;b&gt; Do not attempt to use a direct {@link ByteBuffer} that has been cleaned or bad things will happen. Don't use this class unless you can ensure that the cleaned buffer will not be accessed anymore. &lt;p&gt; &lt;p&gt; See &lt;a href=https:bugs.openjdk.java.netbrowseJDK-4724038&gt;JDK-4724038&lt;a&gt; &lt;p&gt;" />
      <item value="{@link InputStream} implementation which uses direct buffer to read a file to avoid extra copy of data between Java and native memory which happens when using {@link java.io.BufferedInputStream}. Unfortunately, this is not something already available in JDK, {@code sun.nio.ch.ChannelInputStream} supports reading a file using NIO, but does not support buffering. &lt;p&gt; This class was ported and adapted from Apache Spark commit 933dc6cb7b3de1d8ccaf73d124d6eb95b947ed19 where it was called {@code NioBufferedFileInputStream}. &lt;p&gt; @since 2.9.0" />
      <item value="Always throws an {@link IOException} from all the {@link InputStream} methods where the exception is declared. &lt;p&gt; This class is mostly useful for testing error handling. &lt;p&gt; @since 2.0" />
      <item value="A reader that imposes a limit to the number of characters that can be read from an underlying reader, returning EOF when this limit is reached, regardless of state of underlying reader. &lt;p&gt; One use case is to avoid overrunning the readAheadLimit supplied to {@link Readermark(int)}, since reading too many characters removes the ability to do a successful reset. &lt;p&gt; @since 2.5" />
      <item value="A filter reader that filters out a given character represented as an {@code int} code point, handy to remove known junk characters from CSV files for example. This class is the most efficient way to filter out a single character, as opposed to using a {@link CharacterSetFilterReader}. You can also nest {@link CharacterFilterReader}s." />
      <item value="OutputStream implementation that writes the data to an {@link Appendable} Object. &lt;p&gt; For example, can be used with any {@link java.io.Writer} or a {@link StringBuilder} or {@link StringBuffer}. &lt;p&gt; @since 2.5 @see Appendable @param &lt;T&gt; The type of the {@link Appendable} wrapped by this AppendableOutputStream." />
      <item value="The XmlStreamReaderException is thrown by the XmlStreamReader constructors if the charset encoding can not be determined according to the XML 1.0 specification and RFC 3023. &lt;p&gt; The exception returns the unconsumed InputStream to allow the application to do an alternate processing with the stream. Note that the original InputStream given to the XmlStreamReader cannot be used as that one has been already read. &lt;p&gt; @since 2.0" />
      <item value="Character stream that handles all the necessary Voodoo to figure out the charset encoding of the XML document within the stream. &lt;p&gt; IMPORTANT: This class is not related in any way to the org.xml.sax.XMLReader. This one IS a character stream. &lt;p&gt; &lt;p&gt; All this has to be done without consuming characters from the stream, if not the XML parser will not recognized the document as a valid XML. This is not 100% true, but it's close enough (UTF-8 BOM is not handled by all parsers right now, XmlStreamReader handles it and things work in all parsers). &lt;p&gt; &lt;p&gt; The XmlStreamReader class handles the charset encoding of XML documents in Files, raw streams and HTTP streams by offering a wide set of constructors. &lt;p&gt; &lt;p&gt; By default the charset encoding detection is lenient, the constructor with the lenient flag can be used for a script (following HTTP MIME and XML specifications). All this is nicely explained by Mark Pilgrim in his blog, &lt;a href=&quot;http:diveintomark.orgarchives20040213xml-media-types&quot;&gt; Determining the character encoding of a feed&lt;a&gt;. &lt;p&gt; &lt;p&gt; Originally developed for &lt;a href=&quot;http:rome.dev.java.net&quot;&gt;ROME&lt;a&gt; under Apache License 2.0. &lt;p&gt; @see XmlStreamWriter @since 2.0" />
      <item value="Provides the contents of multiple Readers in sequence." />
      <item value="Reads lines in a file reversely (similar to a BufferedReader, but starting at the last line). Useful for e.g. searching in log files." />
      <item value="{@link InputStream} implementation that reads a character stream from a {@link Reader} and transforms it to a byte stream using a specified charset encoding. The stream is transformed using a {@link CharsetEncoder} object, guaranteeing that all charset encodings supported by the JRE are handled correctly. In particular for charsets such as UTF-16, the implementation ensures that one and only one byte order marker is produced. &lt;p&gt; Since in general it is not possible to predict the number of characters to be read from the {@link Reader} to satisfy a read request on the {@link ReaderInputStream}, all reads from the {@link Reader} are buffered. There is therefore no well defined correlation between the current position of the {@link Reader} and that of the {@link ReaderInputStream}. This also implies that in general there is no need to wrap the underlying {@link Reader} in a {@link java.io.BufferedReader}. &lt;p&gt; &lt;p&gt; {@link ReaderInputStream} implements the inverse transformation of {@link java.io.InputStreamReader}; in the following example, reading from {@code in2} would return the same byte sequence as reading from {@code in} (provided that the initial byte sequence is legal with respect to the charset encoding): &lt;p&gt; &lt;pre&gt; InputStream inputStream = ... Charset cs = ... InputStreamReader reader = new InputStreamReader(inputStream, cs); ReaderInputStream in2 = new ReaderInputStream(reader, cs); &lt;pre&gt; &lt;p&gt; {@link ReaderInputStream} implements the same transformation as {@link java.io.OutputStreamWriter}, except that the control flow is reversed: both classes transform a character stream into a byte stream, but {@link java.io.OutputStreamWriter} pushes data to the underlying stream, while {@link ReaderInputStream} pulls it from the underlying stream. &lt;p&gt; &lt;p&gt; Note that while there are use cases where there is no alternative to using this class, very often the need to use this class is an indication of a flaw in the design of the code. This class is typically used in situations where an existing API only accepts an {@link InputStream}, but where the most natural way to produce the data is as a character stream, i.e. by providing a {@link Reader} instance. An example of a situation where this problem may appear is when implementing the {@code javax.activation.DataSource} interface from the Java Activation Framework. &lt;p&gt; &lt;p&gt; The {@link available()} method of this class always returns 0. The methods {@link mark(int)} and {@link reset()} are not supported. &lt;p&gt; &lt;p&gt; Instances of {@link ReaderInputStream} are not thread safe. &lt;p&gt; @see WriterOutputStream @since 2.0" />
      <item value="Implements {@link InputStream} to asynchronously read ahead from an underlying input stream when a specified amount of data has been read from the current buffer. It does so by maintaining two buffers: an active buffer and a read ahead buffer. The active buffer contains data which should be returned when a read() call is issued. The read ahead buffer is used to asynchronously read from the underlying input stream. When the current active buffer is exhausted, we flip the two buffers so that we can start reading from the read ahead buffer without being blocked by disk IO. &lt;p&gt; This class was ported and adapted from Apache Spark commit 933dc6cb7b3de1d8ccaf73d124d6eb95b947ed19. &lt;p&gt;" />
      <item value="@deprecated The finalization mechanism is inherently problematic. Finalization can lead to performance issues, deadlocks, and hangs. Errors in finalizers can lead to resource leaks; there is no way to cancel finalization if it is no longer necessary; and no ordering is specified among calls to {@code finalize} methods of different objects. Furthermore, there are no guarantees regarding the timing of finalization. The {@code finalize} method might be called on a finalizable object only after an indefinite delay, if at all." />
      <item value="The constant for case sensitive regardless of operating system." />
      <item value="Private workerholder that computes and tracks relative path names and their equality. We reuse the sorted relative lists when comparing directories." />
      <item value="Extracts paging information from web requests and thus allows injecting {@link Pageable} instances into controller methods. Request properties to be parsed can be configured. Default configuration uses request parameters beginning with {@link DEFAULT_PAGE_PARAMETER}{@link DEFAULT_QUALIFIER_DELIMITER}. @since 1.6 @author Oliver Gierke @author Nick Williams @author Mark Paluch @author Christoph Strobl" />
      <item value="Returns {@code true} iff &lt;i&gt;a&lt;i&gt; is a sub-collection of &lt;i&gt;b&lt;i&gt;, that is, iff the cardinality of &lt;i&gt;e&lt;i&gt; in &lt;i&gt;a&lt;i&gt; is less than or equal to the cardinality of &lt;i&gt;e&lt;i&gt; in &lt;i&gt;b&lt;i&gt;, for each element &lt;i&gt;e&lt;i&gt; in &lt;i&gt;a&lt;i&gt;. @param a the first (sub?) collection, must not be null @param b the second (super?) collection, must not be null @return {@code true} iff &lt;i&gt;a&lt;i&gt; is a sub-collection of &lt;i&gt;b&lt;i&gt; @throws NullPointerException if either collection is null @see isProperSubCollection @see CollectioncontainsAll" />
      <item value="@return The category of the constructed Logger. By default, it will use the type where the annotation is placed." />
      <item value="Handles any &lt;code&gt;AccessDeniedException&lt;code&gt; and &lt;code&gt;AuthenticationException&lt;code&gt; thrown within the filter chain. &lt;p&gt; This filter is necessary because it provides the bridge between Java exceptions and HTTP responses. It is solely concerned with maintaining the user interface. This filter does not do any actual security enforcement. &lt;p&gt; If an {@link AuthenticationException} is detected, the filter will launch the &lt;code&gt;authenticationEntryPoint&lt;code&gt;. This allows common handling of authentication failures originating from any subclass of {@link org.springframework.security.access.intercept.AbstractSecurityInterceptor}. &lt;p&gt; If an {@link AccessDeniedException} is detected, the filter will determine whether or not the user is an anonymous user. If they are an anonymous user, the &lt;code&gt;authenticationEntryPoint&lt;code&gt; will be launched. If they are not an anonymous user, the filter will delegate to the {@link org.springframework.security.web.access.AccessDeniedHandler}. By default the filter will use {@link org.springframework.security.web.access.AccessDeniedHandlerImpl}. &lt;p&gt; To use this filter, it is necessary to specify the following properties: &lt;ul&gt; &lt;li&gt;&lt;code&gt;authenticationEntryPoint&lt;code&gt; indicates the handler that should commence the authentication process if an &lt;code&gt;AuthenticationException&lt;code&gt; is detected. Note that this may also switch the current protocol from http to https for an SSL login.&lt;li&gt; &lt;li&gt;&lt;tt&gt;requestCache&lt;tt&gt; determines the strategy used to save a request during the authentication process in order that it may be retrieved and reused once the user has authenticated. The default implementation is {@link HttpSessionRequestCache}.&lt;li&gt; &lt;ul&gt; @author Ben Alex @author colin sampaleanu" />
      <item value="Provides a convenient base class for creating a {@link WebSecurityConfigurer} instance. The implementation allows customization by overriding methods. &lt;p&gt; Will automatically apply the result of looking up {@link AbstractHttpConfigurer} from {@link SpringFactoriesLoader} to allow developers to extend the defaults. To do this, you must create a class that extends AbstractHttpConfigurer and then create a file in the classpath at &quot;META-INFspring.factories&quot; that looks something like: &lt;p&gt; &lt;pre&gt; org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer = sample.MyClassThatExtendsAbstractHttpConfigurer &lt;pre&gt; If you have multiple classes that should be added you can use &quot;,&quot; to separate the values. For example: &lt;pre&gt; org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer = sample.MyClassThatExtendsAbstractHttpConfigurer, sample.OtherThatExtendsAbstractHttpConfigurer &lt;pre&gt; @author Rob Winch @see EnableWebSecurity" />
      <item value="Abstract processor of browser-based HTTP-based authentication requests. &lt;h3&gt;Authentication Process&lt;h3&gt; The filter requires that you set the &lt;tt&gt;authenticationManager&lt;tt&gt; property. An &lt;tt&gt;AuthenticationManager&lt;tt&gt; is required to process the authentication request tokens created by implementing classes. &lt;p&gt; This filter will intercept a request and attempt to perform authentication from that request if the request matches the {@link setRequiresAuthenticationRequestMatcher(RequestMatcher)}. &lt;p&gt; Authentication is performed by the {@link attemptAuthentication(HttpServletRequest, HttpServletResponse) attemptAuthentication} method, which must be implemented by subclasses. &lt;h4&gt;Authentication Success&lt;h4&gt; If authentication is successful, the resulting {@link Authentication} object will be placed into the &lt;code&gt;SecurityContext&lt;code&gt; for the current thread, which is guaranteed to have already been created by an earlier filter. &lt;p&gt; The configured {@link setAuthenticationSuccessHandler(AuthenticationSuccessHandler) AuthenticationSuccessHandler} will then be called to take the redirect to the appropriate destination after a successful login. The default behaviour is implemented in a {@link SavedRequestAwareAuthenticationSuccessHandler} which will make use of any &lt;tt&gt;DefaultSavedRequest&lt;tt&gt; set by the &lt;tt&gt;ExceptionTranslationFilter&lt;tt&gt; and redirect the user to the URL contained therein. Otherwise it will redirect to the webapp root &quot;&quot;. You can customize this behaviour by injecting a differently configured instance of this class, or by using a different implementation. &lt;p&gt; See the {@link successfulAuthentication(HttpServletRequest, HttpServletResponse, FilterChain, Authentication)} method for more information. &lt;h4&gt;Authentication Failure&lt;h4&gt; If authentication fails, it will delegate to the configured {@link AuthenticationFailureHandler} to allow the failure information to be conveyed to the client. The default implementation is {@link SimpleUrlAuthenticationFailureHandler} , which sends a 401 error code to the client. It may also be configured with a failure URL as an alternative. Again you can inject whatever behaviour you require here. &lt;h4&gt;Event Publication&lt;h4&gt; If authentication is successful, an {@link InteractiveAuthenticationSuccessEvent} will be published via the application context. No events will be published if authentication was unsuccessful, because this would generally be recorded via an {@code AuthenticationManager}-specific application event. &lt;h4&gt;Session Authentication&lt;h4&gt; The class has an optional {@link SessionAuthenticationStrategy} which will be invoked immediately after a successful call to {@code attemptAuthentication()}. Different implementations {@link setSessionAuthenticationStrategy(SessionAuthenticationStrategy) can be injected} to enable things like session-fixation attack prevention or to control the number of simultaneous sessions a principal may have. @author Ben Alex @author Luke Taylor" />
      <item value="An {@link AccessDeniedHandler} that delegates to other {@link AccessDeniedHandler} instances based upon the type of {@link HttpServletRequest} passed into {@link handle(HttpServletRequest, HttpServletResponse, AccessDeniedException)}. @author Josh Cummings @since 5.1" />
      <item value="Handles an access denied failure. @param request that resulted in an &lt;code&gt;AccessDeniedException&lt;code&gt; @param response so that the user agent can be advised of the failure @param accessDeniedException that caused the invocation @throws IOException in the event of an IOException @throws ServletException in the event of a ServletException" />
      <item value="Access Denied Exception" />
      <item value="Adds HTTP basic based authentication. All attributes have reasonable defaults making all parameters are optional. &lt;h2&gt;Security Filters&lt;h2&gt; The following Filters are populated &lt;ul&gt; &lt;li&gt;{@link BasicAuthenticationFilter}&lt;li&gt; &lt;ul&gt; &lt;h2&gt;Shared Objects Created&lt;h2&gt; &lt;ul&gt; &lt;li&gt;AuthenticationEntryPoint - populated with the {@link authenticationEntryPoint(AuthenticationEntryPoint)} (default {@link BasicAuthenticationEntryPoint})&lt;li&gt; &lt;ul&gt; &lt;h2&gt;Shared Objects Used&lt;h2&gt; The following shared objects are used: &lt;ul&gt; &lt;li&gt;{@link AuthenticationManager}&lt;li&gt; &lt;li&gt;{@link RememberMeServices}&lt;li&gt; &lt;ul&gt; @author Rob Winch @since 3.2" />
      <item value="If &quot;authenticate&quot; was passed to this method it update the defaults as shown below: &lt;ul&gt; &lt;li&gt;authenticate GET - the login form&lt;li&gt; &lt;li&gt;authenticate POST - process the credentials and if valid authenticate the user &lt;li&gt; &lt;li&gt;authenticate?error GET - redirect here for failed authentication attempts&lt;li&gt; &lt;li&gt;authenticate?logout GET - redirect here after successfully logging out&lt;li&gt; &lt;ul&gt; @param loginPage the login page to redirect to if authentication is required (i.e. &quot;login&quot;) @return the {@link FormLoginConfigurer} for additional customization" />
      <item value="Specifies the URL to validate the credentials. @param loginProcessingUrl the URL to validate username and password @return the {@link FormLoginConfigurer} for additional customization" />
      <item value="The example below demonstrates how to configure HTTP Basic authentication for an application. The default realm is &quot;Realm&quot;, but can be customized using" />
      <item value="Bearer Token Access Denied Handler" />
      <item value="Spring Security will never create an {@link HttpSession} and it will never use it to obtain the {@link SecurityContext}" />
      <item value="Create an expression that tests whether its argument are equal, returning null if they are and the value of the first expression if they are not. @param x expression @param y value @return nullif expression" />
      <item value="Find a single {@link Annotation} of {@code annotationType} on the supplied {@link Class}, traversing its interfaces, annotations, and superclasses if the annotation is not &lt;em&gt;directly present&lt;em&gt; on the given class itself. &lt;p&gt;This method explicitly handles class-level annotations which are not declared as {@link java.lang.annotation.Inherited inherited} &lt;em&gt;as well as meta-annotations and annotations on interfaces&lt;em&gt;. &lt;p&gt;The algorithm operates as follows: &lt;ol&gt; &lt;li&gt;Search for the annotation on the given class and return it if found. &lt;li&gt;Recursively search through all annotations that the given class declares. &lt;li&gt;Recursively search through all interfaces that the given class declares. &lt;li&gt;Recursively search through the superclass hierarchy of the given class. &lt;ol&gt; &lt;p&gt;Note: in this context, the term &lt;em&gt;recursively&lt;em&gt; means that the search process continues by returning to step 1 with the current interface, annotation, or superclass as the class to look for annotations on. @param clazz the class to look for annotations on @param annotationType the type of annotation to look for @return the first matching annotation, or {@code null} if not found" />
      <item value="Get a single {@link Annotation} of {@code annotationType} from the supplied annotation: either the given annotation itself or a direct meta-annotation thereof. &lt;p&gt;Note that this method supports only a single level of meta-annotations. For support for arbitrary levels of meta-annotations, use one of the {@code find()} methods instead. @param annotation the Annotation to check @param annotationType the annotation type to look for, both locally and as a meta-annotation @return the first matching annotation, or {@code null} if not found @since 4.0" />
      <item value="Attribute converter persistence unit post processor." />
      <item value="Find whether the parent category is encrypted. If it is found, the result will be returned immediately. Otherwise, it will be found recursively according to parentId." />
      <item value="One or more properties of the result type on which the mapped property depends. The generated method implementation will invoke the setters of the result type ordered so that the given dependency relationship(s) are satisfied. Useful in case one property setter depends on the state of another property of the result type. &lt;p&gt; An error will be raised in case a cycle in the dependency relationships is detected. @return the dependencies of the mapped property" />
      <item value="A qualifier can be specified to aid the selection process of a suitable mapper. This is useful in case multiple mapping methods (hand written or generated) qualify and thus would result in an 'Ambiguous mapping methods found' error. A qualifier is a custom annotation and can be placed on a hand written mapper class or a method. @return the qualifiers" />
      <item value="A qualifier can be specified to aid the selection process of a suitable mapper. This is useful in case multiple mapping methods (hand written or generated) qualify and thus would result in an 'Ambiguous mapping methods found' error. A qualifier is a custom annotation and can be placed on a hand written mapper class or a method. @return the qualifiers @see Qualifier" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="87" />
        <entry key="ENGLISH" value="87" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1656163937732" />
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20190412000287251" />
      </app-key>
    </option>
    <option name="phoneticFontFamily" value="Source Code Pro Medium" />
    <option name="primaryFontFamily" value="Microsoft YaHei UI" />
    <option name="targetLanguageSelection" value="PRIMARY_LANGUAGE" />
    <option name="translateDocumentation" value="true" />
    <option name="translator" value="YOUDAO" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="3289501515931655" />
      </youdao-translate>
    </option>
  </component>
</application>