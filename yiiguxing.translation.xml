<application>
  <component name="AppStorage">
    <option name="lastReplacementTargetLanguage" value="CHINESE" />
    <option name="newTranslationDialogWidth" value="598" />
    <option name="newTranslationDialogX" value="684" />
    <option name="newTranslationDialogY" value="440" />
    <histories>
      <item value="An EOFException could be raised if the broker processes the DISCONNECT and ends the socket before we complete. As such, only shutdown the connection if we're not already shutting down." />
      <item value="NOSONAR - false positive - called from synchronized block" />
      <item value="Base64's mode is set to URL-SAFE." />
      <item value="This is a copy of the STANDARD_ENCODE_TABLE above, but with + and changed to - and _ to make the encoded Base64 results more URL-SAFE. This table is only used when the" />
      <item value="An {@link ImmutableAsList} implementation specialized for when the delegate collection is already backed by an {@code ImmutableList} or array." />
      <item value="Constructs a new runtime exception with the specified detail message, cause, suppression enabled or disabled, and writable stack trace enabled or disabled" />
      <item value="SQLite use table creation sql to define unique constraints." />
      <item value="This example uses docx4j's internal capabilities to update a ToC. For page numbers, you'll need export-fo on your classpath; see https:github.complutextdocx4jtreeVERSION_11_4_6docx4j-samples-docx-export-fo Note: If you have Word available, you can use it to populate (andor update) the ToC. That uses a different code path; please see the TocOperations example in docx4j-samples-export-documents4j-local" />
      <item value="This example uses docx4j's internal capabilities to generate a ToC. To add indicative page numbers, put export-fo on your classpath; see https:github.complutextdocx4jtreeVERSION_11_4_6docx4j-samples-docx-export-fo Note: If you have Word available, you can use it to populate (andor update) the ToC. That uses a different code path; please see the TocOperations example in docx4j-samples-export-documents4j-local" />
      <item value="Helper method to get all but the last element of an array" />
      <item value="Helper method to determine if an {@link Object} array contains a {@link Throwable} as last element" />
      <item value="contributors: lizongbo: proposed special treatment of array parameter values Joern Huxhorn: pointed out double[] omission, suggested deep array copy" />
      <item value="Ensures the truth of an expression involving the state of the calling instance, but not involving a" />
      <item value="Ensures the truth of an expression involving one or more parameters to the calling method." />
      <item value="Annotation that indicates a variable has a weak relationship to its owner. Author: Tom Ball" />
      <item value="Determines whether a BMP character is lower case according to {@linkplain CharacterisLowerCase(char) Java's definition}. @since 19.0 (since 1.0 as constant {@code JAVA_LOWER_CASE}) @deprecated Some lowercase characters are supplementary characters; see the class documentation." />
      <item value="Many digits are supplementary characters; see the class documentation." />
      <item value="Methods factored out so that they can be emulated differently in GWT." />
      <item value="Utility class for converting between various ASCII case formats. Behavior is undefined for non-ASCII input." />
      <item value="A utility method to perform unchecked casts to suppress errors produced by nullness analyses" />
      <item value="A class for arithmetic on values of type {@code int}. Where possible, methods are defined and named analogously to their {@code BigInteger} counterparts." />
      <item value="&lt;p&gt;The implementations of many methods in this class are based on material from Henry S. Warren, Jr.'s &lt;i&gt;Hacker's Delight&lt;i&gt;, (Addison Wesley, 2002)." />
      <item value="Guaranteed to throw an exception and leave the underlying data unmodified." />
      <item value="Implementation of an {@link Optional} not containing a reference" />
      <item value="Returns a predicate that evaluates to {@code true} if the {@code CharSequence} being tested contains any match for the given regular expression pattern. The test used is equivalent to {@code pattern.matcher(arg).find()}" />
      <item value="Provides static methods for working with {@code Collection} instances." />
      <item value="A set which forwards all its method calls to another set. Subclasses should override one or more methods to modify the behavior of the backing set as desired per the &lt;a href=&quot;http:en.wikipedia.orgwikiDecorator_pattern&quot;&gt;decorator pattern&lt;a&gt;" />
      <item value="Returns whether a given set of modifiers implies package access." />
      <item value="XXX Default access superclass workaround." />
      <item value="Contains common code for working with {@link java.lang.reflect.Method Methods}{@link java.lang.reflect.Constructor Constructors}, extracted and refactored from {@link MethodUtils} when it was imported from Commons BeanUtils." />
      <item value="Gets all class level public methods of the given class that are annotated with the given annotation." />
      <item value="Sort methods by signature to force deterministic result" />
      <item value="Finds an accessible method that matches the given name and has compatible parameters. Compatible parameters mean that every method parameter is assignable from the given parameters. In other words, it finds a method with the given name that will take the parameters given." />
      <item value="Invokes a named method whose parameter type matches the object type." />
      <item value="Invokes a method with no parameters." />
      <item value="the declared array of method parameter types" />
      <item value="Given an arguments array passed to a varargs method, return an array of arguments in the canonical form, i.e. an array with the declared number of parameters, and whose last parameter is an array of the varargs type." />
      <item value="Invokes a named method without parameters." />
      <item value="Indicates that the persistence provider should pick an appropriate strategy for the particular database. The &lt;code&gt;AUTO&lt;code&gt; generation strategy may expect a database resource to exist, or it may attempt to create one. A vendor may provide documentation on how to create such resources in the event that it does not support schema generation or cannot create the schema resource at runtime." />
      <item value="Indicates that the persistence provider must assign primary keys for the entity using a database sequence." />
      <item value="Indicates that the persistence provider must assign primary keys for the entity using an underlying database table to ensure uniqueness." />
      <item value="Abstract base class for auditable entities. Stores the audition values in persistent fields." />
      <item value="Intimate status" />
      <item value="Helper class used to resolve String values (either JSON Object field names or regular String values) into Java Enum instances." />
      <item value="Abbreviates a String using ellipses. This will turn &quot;Now is the time for all good men&quot; into &quot;Now is the time for...&quot;" />
      <item value="Performance testing notes (JDK 1.4, Jul03, scolebourne) Whitespace: Character.isWhitespace() is faster than WHITESPACE.indexOf() where WHITESPACE is a string of all whitespace characters Character access: String.charAt(n) versus toCharArray(), then array[n] String.charAt(n) is about 15% worse for a 10K string They are about equal for a length 50 string String.charAt(n) is about 4 times better for a length 3 string String.charAt(n) is best bet overall Append: String.concat about twice as fast as StringBuffer.append (not sure who tested this)" />
      <item value="Unwraps a given string from anther string." />
      <item value="Checks whether the given String is a UN M.49 numeric area code." />
      <item value="Checks whether the given String is a UN M.49 numeric area code. @param str the String to check @return true, is the given String is a UN M.49 numeric area code. private static boolean isNumericAreaCode(final String str) { return StringUtils.isNumeric(str) &amp;&amp; str.length() == 3; } &lt;p&gt;Obtains the list of languages supported for a given country.&lt;p&gt; &lt;p&gt;This method takes a country code and searches to find the languages available for that country. Variant locales are removed.&lt;p&gt; @param countryCode the 2 letter country code, null returns empty @return an unmodifiable List of Locale objects, not null public static List&lt;Locale&gt; languagesByCountry(final String countryCode) { if (countryCode == null) { return Collections.emptyList(); } List&lt;Locale&gt; langs = cLanguagesByCountry.get(countryCode); if (langs == null) { langs = new ArrayList&lt;&gt;(); final List&lt;Locale&gt; locales = availableLocaleList(); for (final Locale locale : locales) { if (countryCode.equals(locale.getCountry()) &amp;&amp; locale.getVariant().isEmpty()) { langs.add(locale); } } langs = Collections.unmodifiableList(langs); cLanguagesByCountry.putIfAbsent(countryCode, langs); langs = cLanguagesByCountry.get(countryCode); } return langs; } &lt;p&gt;Obtains the list of locales to search through when performing a locale search.&lt;p&gt; &lt;pre&gt; localeLookupList(Locale(&quot;fr&quot;, &quot;CA&quot;, &quot;xxx&quot;)) = [Locale(&quot;fr&quot;, &quot;CA&quot;, &quot;xxx&quot;), Locale(&quot;fr&quot;, &quot;CA&quot;), Locale(&quot;fr&quot;)] &lt;pre&gt; @param locale the locale to start from @return the unmodifiable list of Locale objects, 0 being locale, not null public static List&lt;Locale&gt; localeLookupList(final Locale locale) { return localeLookupList(locale, locale); } &lt;p&gt;Obtains the list of locales to search through when performing a locale search.&lt;p&gt; &lt;pre&gt; localeLookupList(Locale(&quot;fr&quot;, &quot;CA&quot;, &quot;xxx&quot;), Locale(&quot;en&quot;)) = [Locale(&quot;fr&quot;, &quot;CA&quot;, &quot;xxx&quot;), Locale(&quot;fr&quot;, &quot;CA&quot;), Locale(&quot;fr&quot;), Locale(&quot;en&quot;] &lt;pre&gt; &lt;p&gt;The result list begins with the most specific locale, then the next more general and so on, finishing with the default locale. The list will never contain the same locale twice.&lt;p&gt; @param locale the locale to start from, null returns empty list @param defaultLocale the default locale to use if no other is found @return the unmodifiable list of Locale objects, 0 being locale, not null public static List&lt;Locale&gt; localeLookupList(final Locale locale, final Locale defaultLocale) { final List&lt;Locale&gt; list = new ArrayList&lt;&gt;(4); if (locale != null) { list.add(locale); if (!locale.getVariant().isEmpty()) { list.add(new Locale(locale.getLanguage(), locale.getCountry())); } if (!locale.getCountry().isEmpty()) { list.add(new Locale(locale.getLanguage(), StringUtils.EMPTY)); } if (!list.contains(defaultLocale)) { list.add(defaultLocale); } } return Collections.unmodifiableList(list); } Tries to parse a locale from the given String. @param str the String to parse a locale from. @return a Locale instance parsed from the given String. @throws IllegalArgumentException if the given String can not be parsed. private static Locale parseLocale(final String str) { if (isISO639LanguageCode(str)) { return new Locale(str); } final String[] segments = str.split(&quot;_&quot;, -1); final String language = segments[0]; if (segments.length == 2) { final String country = segments[1]; if (isISO639LanguageCode(language) &amp;&amp; isISO3166CountryCode(country) || isNumericAreaCode(country)) { return new Locale(language, country); } } else if (segments.length == 3) { final String country = segments[1]; final String variant = segments[2]; if (isISO639LanguageCode(language) &amp;&amp; (country.isEmpty() || isISO3166CountryCode(country) || isNumericAreaCode(country)) &amp;&amp; !variant.isEmpty()) { return new Locale(language, country, variant); } } throw new IllegalArgumentException(&quot;Invalid locale format: &quot; + str); } Returns the given locale if non-{@code null}, otherwise {@link LocalegetDefault()}. @param locale a locale or {@code null}. @return the given locale if non-{@code null}, otherwise {@link LocalegetDefault()}. public static Locale toLocale(final Locale locale) { return locale != null ? locale : Locale.getDefault(); } &lt;p&gt;Converts a String to a Locale.&lt;p&gt; &lt;p&gt;This method takes the string format of a locale and creates the locale object from it.&lt;p&gt; &lt;pre&gt; LocaleUtils.toLocale(&quot;&quot;) = new Locale(&quot;&quot;, &quot;&quot;) LocaleUtils.toLocale(&quot;en&quot;) = new Locale(&quot;en&quot;, &quot;&quot;) LocaleUtils.toLocale(&quot;en_GB&quot;) = new Locale(&quot;en&quot;, &quot;GB&quot;) LocaleUtils.toLocale(&quot;en_001&quot;) = new Locale(&quot;en&quot;, &quot;001&quot;) LocaleUtils.toLocale(&quot;en_GB_xxx&quot;) = new Locale(&quot;en&quot;, &quot;GB&quot;, &quot;xxx&quot;) () &lt;pre&gt; &lt;p&gt;() The behavior of the JDK variant constructor changed between JDK1.3 and JDK1.4. In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't. Thus, the result from getVariant() may vary depending on your JDK.&lt;p&gt; &lt;p&gt;This method validates the input strictly. The language code must be lowercase. The country code must be uppercase. The separator must be an underscore. The length must be correct. &lt;p&gt; @param str the locale String to convert, null returns null @return a Locale, null if null input @throws IllegalArgumentException if the string is an invalid format @see LocaleforLanguageTag(String) public static Locale toLocale(final String str) { if (str == null) { return null; } if (str.isEmpty()) { LANG-941 - JDK 8 introduced an empty locale where all fields are blank return new Locale(StringUtils.EMPTY, StringUtils.EMPTY); } if (str.contains(&quot;&quot;)) { LANG-879 - Cannot handle Java 7 script &amp; extensions throw new IllegalArgumentException(&quot;Invalid locale format: &quot; + str); } final int len = str.length(); if (len &lt; 2) { throw new IllegalArgumentException(&quot;Invalid locale format: &quot; + str); } final char ch0 = str.charAt(0); if (ch0 == '_') { if (len &lt; 3) { throw new IllegalArgumentException(&quot;Invalid locale format: &quot; + str); } final char ch1 = str.charAt(1); final char ch2 = str.charAt(2); if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { throw new IllegalArgumentException(&quot;Invalid locale format: &quot; + str); } if (len == 3) { return new Locale(StringUtils.EMPTY, str.substring(1, 3)); } if (len &lt; 5) { throw new IllegalArgumentException(&quot;Invalid locale format: &quot; + str); } if (str.charAt(3) != '_') { throw new IllegalArgumentException(&quot;Invalid locale format: &quot; + str); } return new Locale(StringUtils.EMPTY, str.substring(1, 3), str.substring(4)); } return parseLocale(str); } &lt;p&gt;{@code LocaleUtils} instances should NOT be constructed in standard programming. Instead, the class should be used as {@code LocaleUtils.toLocale(&quot;en_GB&quot;);}.&lt;p&gt; &lt;p&gt;This constructor is public to permit tools that require a JavaBean instance to operate.&lt;p&gt;" />
      <item value="if the given String is a ISO 639 compliant language code." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="251" />
        <entry key="ENGLISH" value="247" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1664007741459" />
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20190412000287251" />
      </app-key>
    </option>
    <option name="phoneticFontFamily" value="Source Code Pro Medium" />
    <option name="primaryFontFamily" value="Microsoft YaHei UI" />
    <option name="showReplacementActionInContextMenu" value="true" />
    <option name="targetLanguageSelection" value="PRIMARY_LANGUAGE" />
    <option name="translateDocumentation" value="true" />
    <option name="translator" value="YOUDAO" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="3289501515931655" />
        <option name="primaryLanguage" value="CHINESE" />
      </youdao-translate>
    </option>
  </component>
</application>