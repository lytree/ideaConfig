<application>
  <component name="AppStorage">
    <option name="lastReplacementTargetLanguage" value="CHINESE" />
    <option name="newTranslationDialogWidth" value="598" />
    <option name="newTranslationDialogX" value="684" />
    <option name="newTranslationDialogY" value="440" />
    <histories>
      <item value="Abbreviates a String using ellipses. This will turn &quot;Now is the time for all good men&quot; into &quot;Now is the time for...&quot;" />
      <item value="Performance testing notes (JDK 1.4, Jul03, scolebourne) Whitespace: Character.isWhitespace() is faster than WHITESPACE.indexOf() where WHITESPACE is a string of all whitespace characters Character access: String.charAt(n) versus toCharArray(), then array[n] String.charAt(n) is about 15% worse for a 10K string They are about equal for a length 50 string String.charAt(n) is about 4 times better for a length 3 string String.charAt(n) is best bet overall Append: String.concat about twice as fast as StringBuffer.append (not sure who tested this)" />
      <item value="Unwraps a given string from anther string." />
      <item value="Checks whether the given String is a UN M.49 numeric area code." />
      <item value="Checks whether the given String is a UN M.49 numeric area code. @param str the String to check @return true, is the given String is a UN M.49 numeric area code. private static boolean isNumericAreaCode(final String str) { return StringUtils.isNumeric(str) &amp;&amp; str.length() == 3; } &lt;p&gt;Obtains the list of languages supported for a given country.&lt;p&gt; &lt;p&gt;This method takes a country code and searches to find the languages available for that country. Variant locales are removed.&lt;p&gt; @param countryCode the 2 letter country code, null returns empty @return an unmodifiable List of Locale objects, not null public static List&lt;Locale&gt; languagesByCountry(final String countryCode) { if (countryCode == null) { return Collections.emptyList(); } List&lt;Locale&gt; langs = cLanguagesByCountry.get(countryCode); if (langs == null) { langs = new ArrayList&lt;&gt;(); final List&lt;Locale&gt; locales = availableLocaleList(); for (final Locale locale : locales) { if (countryCode.equals(locale.getCountry()) &amp;&amp; locale.getVariant().isEmpty()) { langs.add(locale); } } langs = Collections.unmodifiableList(langs); cLanguagesByCountry.putIfAbsent(countryCode, langs); langs = cLanguagesByCountry.get(countryCode); } return langs; } &lt;p&gt;Obtains the list of locales to search through when performing a locale search.&lt;p&gt; &lt;pre&gt; localeLookupList(Locale(&quot;fr&quot;, &quot;CA&quot;, &quot;xxx&quot;)) = [Locale(&quot;fr&quot;, &quot;CA&quot;, &quot;xxx&quot;), Locale(&quot;fr&quot;, &quot;CA&quot;), Locale(&quot;fr&quot;)] &lt;pre&gt; @param locale the locale to start from @return the unmodifiable list of Locale objects, 0 being locale, not null public static List&lt;Locale&gt; localeLookupList(final Locale locale) { return localeLookupList(locale, locale); } &lt;p&gt;Obtains the list of locales to search through when performing a locale search.&lt;p&gt; &lt;pre&gt; localeLookupList(Locale(&quot;fr&quot;, &quot;CA&quot;, &quot;xxx&quot;), Locale(&quot;en&quot;)) = [Locale(&quot;fr&quot;, &quot;CA&quot;, &quot;xxx&quot;), Locale(&quot;fr&quot;, &quot;CA&quot;), Locale(&quot;fr&quot;), Locale(&quot;en&quot;] &lt;pre&gt; &lt;p&gt;The result list begins with the most specific locale, then the next more general and so on, finishing with the default locale. The list will never contain the same locale twice.&lt;p&gt; @param locale the locale to start from, null returns empty list @param defaultLocale the default locale to use if no other is found @return the unmodifiable list of Locale objects, 0 being locale, not null public static List&lt;Locale&gt; localeLookupList(final Locale locale, final Locale defaultLocale) { final List&lt;Locale&gt; list = new ArrayList&lt;&gt;(4); if (locale != null) { list.add(locale); if (!locale.getVariant().isEmpty()) { list.add(new Locale(locale.getLanguage(), locale.getCountry())); } if (!locale.getCountry().isEmpty()) { list.add(new Locale(locale.getLanguage(), StringUtils.EMPTY)); } if (!list.contains(defaultLocale)) { list.add(defaultLocale); } } return Collections.unmodifiableList(list); } Tries to parse a locale from the given String. @param str the String to parse a locale from. @return a Locale instance parsed from the given String. @throws IllegalArgumentException if the given String can not be parsed. private static Locale parseLocale(final String str) { if (isISO639LanguageCode(str)) { return new Locale(str); } final String[] segments = str.split(&quot;_&quot;, -1); final String language = segments[0]; if (segments.length == 2) { final String country = segments[1]; if (isISO639LanguageCode(language) &amp;&amp; isISO3166CountryCode(country) || isNumericAreaCode(country)) { return new Locale(language, country); } } else if (segments.length == 3) { final String country = segments[1]; final String variant = segments[2]; if (isISO639LanguageCode(language) &amp;&amp; (country.isEmpty() || isISO3166CountryCode(country) || isNumericAreaCode(country)) &amp;&amp; !variant.isEmpty()) { return new Locale(language, country, variant); } } throw new IllegalArgumentException(&quot;Invalid locale format: &quot; + str); } Returns the given locale if non-{@code null}, otherwise {@link LocalegetDefault()}. @param locale a locale or {@code null}. @return the given locale if non-{@code null}, otherwise {@link LocalegetDefault()}. public static Locale toLocale(final Locale locale) { return locale != null ? locale : Locale.getDefault(); } &lt;p&gt;Converts a String to a Locale.&lt;p&gt; &lt;p&gt;This method takes the string format of a locale and creates the locale object from it.&lt;p&gt; &lt;pre&gt; LocaleUtils.toLocale(&quot;&quot;) = new Locale(&quot;&quot;, &quot;&quot;) LocaleUtils.toLocale(&quot;en&quot;) = new Locale(&quot;en&quot;, &quot;&quot;) LocaleUtils.toLocale(&quot;en_GB&quot;) = new Locale(&quot;en&quot;, &quot;GB&quot;) LocaleUtils.toLocale(&quot;en_001&quot;) = new Locale(&quot;en&quot;, &quot;001&quot;) LocaleUtils.toLocale(&quot;en_GB_xxx&quot;) = new Locale(&quot;en&quot;, &quot;GB&quot;, &quot;xxx&quot;) () &lt;pre&gt; &lt;p&gt;() The behavior of the JDK variant constructor changed between JDK1.3 and JDK1.4. In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't. Thus, the result from getVariant() may vary depending on your JDK.&lt;p&gt; &lt;p&gt;This method validates the input strictly. The language code must be lowercase. The country code must be uppercase. The separator must be an underscore. The length must be correct. &lt;p&gt; @param str the locale String to convert, null returns null @return a Locale, null if null input @throws IllegalArgumentException if the string is an invalid format @see LocaleforLanguageTag(String) public static Locale toLocale(final String str) { if (str == null) { return null; } if (str.isEmpty()) { LANG-941 - JDK 8 introduced an empty locale where all fields are blank return new Locale(StringUtils.EMPTY, StringUtils.EMPTY); } if (str.contains(&quot;&quot;)) { LANG-879 - Cannot handle Java 7 script &amp; extensions throw new IllegalArgumentException(&quot;Invalid locale format: &quot; + str); } final int len = str.length(); if (len &lt; 2) { throw new IllegalArgumentException(&quot;Invalid locale format: &quot; + str); } final char ch0 = str.charAt(0); if (ch0 == '_') { if (len &lt; 3) { throw new IllegalArgumentException(&quot;Invalid locale format: &quot; + str); } final char ch1 = str.charAt(1); final char ch2 = str.charAt(2); if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { throw new IllegalArgumentException(&quot;Invalid locale format: &quot; + str); } if (len == 3) { return new Locale(StringUtils.EMPTY, str.substring(1, 3)); } if (len &lt; 5) { throw new IllegalArgumentException(&quot;Invalid locale format: &quot; + str); } if (str.charAt(3) != '_') { throw new IllegalArgumentException(&quot;Invalid locale format: &quot; + str); } return new Locale(StringUtils.EMPTY, str.substring(1, 3), str.substring(4)); } return parseLocale(str); } &lt;p&gt;{@code LocaleUtils} instances should NOT be constructed in standard programming. Instead, the class should be used as {@code LocaleUtils.toLocale(&quot;en_GB&quot;);}.&lt;p&gt; &lt;p&gt;This constructor is public to permit tools that require a JavaBean instance to operate.&lt;p&gt;" />
      <item value="if the given String is a ISO 639 compliant language code." />
      <item value="Checks whether the given String is a ISO 639 compliant language code." />
      <item value="is the given String is a ISO 3166 compliant country code." />
      <item value="the String to check" />
      <item value="Checks whether the given String is a ISO 3166 alpha-2 country code." />
      <item value="true if the locale is a known locale" />
      <item value="the Locale object to check if it is available" />
      <item value="Checks if the locale specified is in the list of available locales." />
      <item value="an unmodifiable List of Locale objects, not null" />
      <item value="the 2 letter language code, null returns empty" />
      <item value="This method takes a language code and searches to find the countries available for that language. Variant locales are removed." />
      <item value="Obtains the list of countries supported for a given language." />
      <item value="the unmodifiable set of available locales" />
      <item value="his method is a wrapper around {@link LocalegetAvailableLocales()}. It is more efficient, as the JDK method must create a new array each time it is called." />
      <item value="Obtains an unmodifiable set of installed locales." />
      <item value="&lt;p&gt;Obtains an unmodifiable list of installed locales.&lt;p&gt; &lt;p&gt;This method is a wrapper around {@link LocalegetAvailableLocales()}. It is more efficient, as the JDK method must create a new array each time it is called.&lt;p&gt; @return the unmodifiable list of available locales" />
      <item value="Concurrent map of country locales by language." />
      <item value="Concurrent map of language locales by country." />
      <item value="Unmodifiable set of available locales." />
      <item value="Unmodifiable list of available locales." />
      <item value="&lt;p&gt;Operations to assist when working with a {@link Locale}.&lt;p&gt; &lt;p&gt;This class tries to handle {@code null} input gracefully. An exception will not be thrown for a {@code null} input. Each method documents its behavior in more detail.&lt;p&gt;" />
      <item value="Recycle status." />
      <item value="Intimate status" />
      <item value="Original content,not format." />
      <item value="Deprecated use the Little Endian accessors, e.g. getShortLE, getIntLE instead of creating a buffer with swapped endianness." />
      <item value="A channel that sends Messages to each of its subscribers. Author: Mark Fisher, Oleg Zhurakousky, Gary Russell, Artem Bilan, Trung Pham" />
      <item value="Simple contract for handling a Message." />
      <item value="Defines methods for sending messages." />
      <item value="A message implementation that is produced by an advice after successful message handling. Contains the result of the expression evaluation in the payload and the original message that the advice passed to the handler." />
      <item value="ChannelOutboundHandlerAdapter which encodes message in a stream-like fashion from one message to an ByteBuf. Example implementation which encodes Integers to a ByteBuf. public class IntegerEncoder extends MessageToByteEncoder&lt;Integer&gt; { @Override public void encode(ChannelHandlerContext ctx, Integer msg, ByteBuf out) throws Exception { out.writeInt(msg); } }" />
      <item value="An encoder that prepends the length of the message. The length value is prepended as a binary form. For example, LengthFieldPrepender(2) will encode the following 12-bytes string: +----------------+ | &quot;HELLO, WORLD&quot; | +----------------+ into the following: +--------+----------------+ + 0x000C | &quot;HELLO, WORLD&quot; | +--------+----------------+ If you turned on the lengthIncludesLengthFieldLength flag in the constructor, the encoded data would look like the following (12 (original data) + 2 (prepended data) = 14 (0xE)): +--------+----------------+ + 0x000E | &quot;HELLO, WORLD&quot; | +--------+----------------+" />
      <item value="daemon" />
      <item value="The method {@link setScale(int, RoundingMode)} should be used in preference to this legacy method." />
      <item value="Returns a {@code BigDecimal} whose scale is the specified value, and whose unscaled value is determined by multiplying or dividing this {@code BigDecimal}'s unscaled value by the appropriate power of ten to maintain its overall value. If the scale is reduced by the operation, the unscaled value must be divided (rather than multiplied), and the value may be changed; in this case, the specified rounding mode is applied to the division. @apiNote Since BigDecimal objects are immutable, calls of this method do &lt;em&gt;not&lt;em&gt; result in the original object being modified, contrary to the usual convention of having methods named &lt;code&gt;set&lt;i&gt;X&lt;i&gt;&lt;code&gt; mutate field &lt;i&gt;{@code X}&lt;i&gt;. Instead, {@code setScale} returns an object with the proper scale; the returned object may or may not be newly allocated. @deprecated The method {@link setScale(int, RoundingMode)} should be used in preference to this legacy method. @param newScale scale of the {@code BigDecimal} value to be returned. @param roundingMode The rounding mode to apply. @return a {@code BigDecimal} whose scale is the specified value, and whose unscaled value is determined by multiplying or dividing this {@code BigDecimal}'s unscaled value by the appropriate power of ten to maintain its overall value. @throws ArithmeticException if {@code roundingMode==ROUND_UNNECESSARY} and the specified scaling operation would require rounding. @throws IllegalArgumentException if {@code roundingMode} does not represent a valid rounding mode. @see ROUND_UP @see ROUND_DOWN @see ROUND_CEILING @see ROUND_FLOOR @see ROUND_HALF_UP @see ROUND_HALF_DOWN @see ROUND_HALF_EVEN @see ROUND_UNNECESSARY" />
      <item value="The annotated element must be {@code null}. Accepts any type." />
      <item value="Returns the minimum value in an array." />
      <item value="the minimum value in the array" />
      <item value="an array, must not be null or empty" />
      <item value="Provides IEEE-754r variants of NumberUtils methods." />
      <item value="Provides extra functionality for Java Number classes." />
      <item value="&lt;p&gt;&lt;b&gt;Date Validation&lt;b&gt; and Conversion routines (&lt;code&gt;java.util.Date&lt;code&gt;).&lt;p&gt; &lt;p&gt;This validator provides a number of methods for validatingconverting a &lt;code&gt;String&lt;code&gt; date value to a &lt;code&gt;java.util.Date&lt;code&gt; using &lt;code&gt;java.text.DateFormat&lt;code&gt; to parse either:&lt;p&gt; &lt;ul&gt; &lt;li&gt;using the default format for the default &lt;code&gt;Locale&lt;code&gt;&lt;li&gt; &lt;li&gt;using a specified pattern with the default &lt;code&gt;Locale&lt;code&gt;&lt;li&gt; &lt;li&gt;using the default format for a specified &lt;code&gt;Locale&lt;code&gt;&lt;li&gt; &lt;li&gt;using a specified pattern with a specified &lt;code&gt;Locale&lt;code&gt;&lt;li&gt; &lt;ul&gt; &lt;p&gt;For each of the above mechanisms, conversion method (i.e the &lt;code&gt;validate&lt;code&gt; methods) implementations are provided which either use the default &lt;code&gt;TimeZone&lt;code&gt; or allow the &lt;code&gt;TimeZone&lt;code&gt; to be specified.&lt;p&gt; &lt;p&gt;Use one of the &lt;code&gt;isValid()&lt;code&gt; methods to just validate or one of the &lt;code&gt;validate()&lt;code&gt; methods to validate and receive a &lt;i&gt;converted&lt;i&gt; &lt;code&gt;Date&lt;code&gt; value.&lt;p&gt; &lt;p&gt;Implementations of the &lt;code&gt;validate()&lt;code&gt; method are provided to create &lt;code&gt;Date&lt;code&gt; objects for different &lt;i&gt;time zones&lt;i&gt; if the system default is not appropriate.&lt;p&gt; &lt;p&gt;Once a value has been successfully converted the following methods can be used to perform various date comparison checks:&lt;p&gt; &lt;ul&gt; &lt;li&gt;&lt;code&gt;compareDates()&lt;code&gt; compares the day, month and year of two dates, returning 0, -1 or +1 indicating whether the first date is equal, before or after the second.&lt;li&gt; &lt;li&gt;&lt;code&gt;compareWeeks()&lt;code&gt; compares the week and year of two dates, returning 0, -1 or +1 indicating whether the first week is equal, before or after the second.&lt;li&gt; &lt;li&gt;&lt;code&gt;compareMonths()&lt;code&gt; compares the month and year of two dates, returning 0, -1 or +1 indicating whether the first month is equal, before or after the second.&lt;li&gt; &lt;li&gt;&lt;code&gt;compareQuarters()&lt;code&gt; compares the quarter and year of two dates, returning 0, -1 or +1 indicating whether the first quarter is equal, before or after the second.&lt;li&gt; &lt;li&gt;&lt;code&gt;compareYears()&lt;code&gt; compares the year of two dates, returning 0, -1 or +1 indicating whether the first year is equal, before or after the second.&lt;li&gt; &lt;ul&gt; &lt;p&gt;So that the same mechanism used for parsing an &lt;i&gt;input&lt;i&gt; value for validation can be used to format &lt;i&gt;output&lt;i&gt;, corresponding &lt;code&gt;format()&lt;code&gt; methods are also provided. That is you can format either:&lt;p&gt; &lt;ul&gt; &lt;li&gt;using a specified pattern&lt;li&gt; &lt;li&gt;using the format for a specified &lt;code&gt;Locale&lt;code&gt;&lt;li&gt; &lt;li&gt;using the format for the &lt;i&gt;default&lt;i&gt; &lt;code&gt;Locale&lt;code&gt;&lt;li&gt; &lt;ul&gt; @version Revision" />
      <item value="&lt;p&gt;{@code Fraction} is a {@code Number} implementation that stores fractions accurately.&lt;p&gt; &lt;p&gt;This class is immutable, and interoperable with most methods that accept a {@code Number}.&lt;p&gt; &lt;p&gt;Note that this class is intended for common use cases, it is &lt;i&gt;int&lt;i&gt; based and thus suffers from various overflow issues. For a BigInteger based equivalent, please see the Commons Math BigFraction class. &lt;p&gt;" />
      <item value="More specifically, this method returns {@code true} if the {@code String} is not {@code null}, its length is greater than 0, and it contains at least one non-whitespace character." />
      <item value="More specifically, this method returns {@code true} if the" />
      <item value="Check whether the given {@code String} contains actual &lt;em&gt;text&lt;em&gt;." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="206" />
        <entry key="ENGLISH" value="202" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1659058047867" />
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20190412000287251" />
      </app-key>
    </option>
    <option name="phoneticFontFamily" value="Source Code Pro Medium" />
    <option name="primaryFontFamily" value="Microsoft YaHei UI" />
    <option name="showReplacementActionInContextMenu" value="true" />
    <option name="targetLanguageSelection" value="PRIMARY_LANGUAGE" />
    <option name="translateDocumentation" value="true" />
    <option name="translator" value="YOUDAO" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="3289501515931655" />
        <option name="primaryLanguage" value="CHINESE" />
      </youdao-translate>
    </option>
  </component>
</application>