<application>
  <component name="AppStorage">
    <histories>
      <item value="Spring Security will never create an {@link HttpSession} and it will never use it to obtain the {@link SecurityContext}" />
      <item value="Create an expression that tests whether its argument are equal, returning null if they are and the value of the first expression if they are not. @param x expression @param y value @return nullif expression" />
      <item value="Find a single {@link Annotation} of {@code annotationType} on the supplied {@link Class}, traversing its interfaces, annotations, and superclasses if the annotation is not &lt;em&gt;directly present&lt;em&gt; on the given class itself. &lt;p&gt;This method explicitly handles class-level annotations which are not declared as {@link java.lang.annotation.Inherited inherited} &lt;em&gt;as well as meta-annotations and annotations on interfaces&lt;em&gt;. &lt;p&gt;The algorithm operates as follows: &lt;ol&gt; &lt;li&gt;Search for the annotation on the given class and return it if found. &lt;li&gt;Recursively search through all annotations that the given class declares. &lt;li&gt;Recursively search through all interfaces that the given class declares. &lt;li&gt;Recursively search through the superclass hierarchy of the given class. &lt;ol&gt; &lt;p&gt;Note: in this context, the term &lt;em&gt;recursively&lt;em&gt; means that the search process continues by returning to step 1 with the current interface, annotation, or superclass as the class to look for annotations on. @param clazz the class to look for annotations on @param annotationType the type of annotation to look for @return the first matching annotation, or {@code null} if not found" />
      <item value="Get a single {@link Annotation} of {@code annotationType} from the supplied annotation: either the given annotation itself or a direct meta-annotation thereof. &lt;p&gt;Note that this method supports only a single level of meta-annotations. For support for arbitrary levels of meta-annotations, use one of the {@code find()} methods instead. @param annotation the Annotation to check @param annotationType the annotation type to look for, both locally and as a meta-annotation @return the first matching annotation, or {@code null} if not found @since 4.0" />
      <item value="Attribute converter persistence unit post processor." />
      <item value="Find whether the parent category is encrypted. If it is found, the result will be returned immediately. Otherwise, it will be found recursively according to parentId." />
      <item value="One or more properties of the result type on which the mapped property depends. The generated method implementation will invoke the setters of the result type ordered so that the given dependency relationship(s) are satisfied. Useful in case one property setter depends on the state of another property of the result type. &lt;p&gt; An error will be raised in case a cycle in the dependency relationships is detected. @return the dependencies of the mapped property" />
      <item value="A qualifier can be specified to aid the selection process of a suitable mapper. This is useful in case multiple mapping methods (hand written or generated) qualify and thus would result in an 'Ambiguous mapping methods found' error. A qualifier is a custom annotation and can be placed on a hand written mapper class or a method. @return the qualifiers" />
      <item value="A qualifier can be specified to aid the selection process of a suitable mapper. This is useful in case multiple mapping methods (hand written or generated) qualify and thus would result in an 'Ambiguous mapping methods found' error. A qualifier is a custom annotation and can be placed on a hand written mapper class or a method. @return the qualifiers @see Qualifier" />
      <item value="Get post with the latest content by id. content from patch log." />
      <item value="The actual content of the post obtained by applying patch to V1 version." />
      <item value="Shifts the order of the given float array." />
      <item value="andomly permutes the elements of the specified array using the Fisher-Yates algorithm." />
      <item value="&lt;p&gt;Produces a new {@code boolean} array containing the elements between the start and end indices. &lt;p&gt;The start index is inclusive, the end index exclusive. Null array input produces null output." />
      <item value="Reverses the order of the given array in the given range." />
      <item value="Gets an array containing the sole value of {@link Object} if {@link WildcardTypegetUpperBounds()} returns an empty array. Otherwise, it returns the result of {@link WildcardTypegetUpperBounds()} passed into {@link normalizeUpperBounds}. @param wildcardType the subject wildcard type, not {@code null} @return a non-empty array containing the upper bounds of the wildcard type." />
      <item value="Gets an array containing the sole value of {@link Object} if {@link WildcardTypegetUpperBounds()} returns an empty array. Otherwise, it returns the result of {@link WildcardTypegetUpperBounds()} passed into {@link normalizeUpperBounds}." />
      <item value="This class implements the {@code Map} interface with a hash table, using reference-equality in place of object-equality when comparing keys (and values). In other words, in an {@code IdentityHashMap}, two keys {@code k1} and {@code k2} are considered equal if and only if {@code (k1==k2)}. (In normal {@code Map} implementations (like {@code HashMap}) two keys {@code k1} and {@code k2} are considered equal if and only if {@code (k1==null ? k2==null : k1.equals(k2))}.) &lt;p&gt;&lt;b&gt;This class is &lt;i&gt;not&lt;i&gt; a general-purpose {@code Map} implementation! While this class implements the {@code Map} interface, it intentionally violates {@code Map's} general contract, which mandates the use of the {@code equals} method when comparing objects. This class is designed for use only in the rare cases wherein reference-equality semantics are required.&lt;b&gt; &lt;p&gt;A typical use of this class is &lt;i&gt;topology-preserving object graph transformations&lt;i&gt;, such as serialization or deep-copying. To perform such a transformation, a program must maintain a &quot;node table&quot; that keeps track of all the object references that have already been processed. The node table must not equate distinct objects even if they happen to be equal. Another typical use of this class is to maintain &lt;i&gt;proxy objects&lt;i&gt;. For example, a debugging facility might wish to maintain a proxy object for each object in the program being debugged. &lt;p&gt;This class provides all of the optional map operations, and permits {@code null} values and the {@code null} key. This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time." />
      <item value="Set properties with method names as keys and transaction attribute descriptors (parsed via TransactionAttributeEditor) as values: e.g. key = &quot;myMethod&quot;, value = &quot;PROPAGATION_REQUIRED,readOnly&quot;. &lt;p&gt;Note: Method names are always applied to the target class, no matter if defined in an interface or the class itself. &lt;p&gt;Internally, a NameMatchTransactionAttributeSource will be created from the given properties." />
      <item value="hash for forwarding nodes" />
      <item value="The smallest table capacity for which bins may be treeified. (Otherwise the table is resized if too many nodes in a bin.) The value should be at least 4 TREEIFY_THRESHOLD to avoid conflicts between resizing and treeification thresholds." />
      <item value="Handling edge case: Joda-time can only handle up to year 292278993 but we are given 292278994; So we parse the date string by first adjusting the year to 292278993. Then we add 1 year back afterwards." />
      <item value="Returns the read limit for mark-and-reset during retries; or -1 if not available." />
      <item value="It is highly recommended to fix these problems because they threaten the stability of your build. For this reason, future Maven versions might no longer support building such malformed projects." />
      <item value="allow Circular References" />
      <item value="Eagerly caching bean 'linkMapper' to allow for resolving potential circular references" />
      <item value="is Singleton Currently In Creation" />
      <item value="Eagerly cache singletons to be able to resolve circular references even when triggered by lifecycle interfaces like BeanFactoryAware." />
      <item value="Add the given singleton factory for building the specified singleton if necessary. To be called for eager registration of singletons, e.g. to be able to resolve circular references. Params: beanName – the name of the bean singletonFactory – the factory for the singleton object" />
      <item value="Simple implementation of the {@link ApplicationEventMulticaster} interface. &lt;p&gt;Multicasts all events to all registered listeners, leaving it up to the listeners to ignore events that they are not interested in. Listeners will usually perform corresponding {@code instanceof} checks on the passed-in event object. &lt;p&gt;By default, all listeners are invoked in the calling thread. This allows the danger of a rogue listener blocking the entire application, but adds minimal overhead. Specify an alternative task executor to have listeners executed in different threads, for example from a thread pool." />
      <item value="Propagate refresh to lifecycle processor first." />
      <item value="{@link BeanFactoryPostProcessor} used for bootstrapping processing of {@link Configuration @Configuration} classes. &lt;p&gt;Registered by default when using {@code &lt;context:annotation-config&gt;} or {@code &lt;context:component-scan&gt;}. Otherwise, may be declared manually as with any other {@link BeanFactoryPostProcessor}. &lt;p&gt;This post processor is priority-ordered as it is important that any {@link Bean @Bean} methods declared in {@code @Configuration} classes have their corresponding bean definitions registered before any other {@code BeanFactoryPostProcessor} executes." />
      <item value="registry Processors" />
      <item value="regular Post Processors" />
      <item value="Tell the subclass to refresh the internal bean factory." />
      <item value="Flag that indicates whether this context has been closed already." />
      <item value="Step recording metrics about a particular phase or action happening during the {@link ApplicationStartup}. &lt;p&gt;The lifecycle of a {@code StartupStep} goes as follows: &lt;ol&gt; &lt;li&gt;the step is created and starts by calling {@link ApplicationStartupstart(String) the application startup} and is assigned a unique {@link StartupStepgetId() id}. &lt;li&gt;we can then attach information with {@link Tags} during processing &lt;li&gt;we then need to mark the {@link end()} of the step &lt;ol&gt; &lt;p&gt;Implementations can track the &quot;execution time&quot; or other metrics for steps." />
      <item value="Prepare this context for refreshing" />
      <item value="Create proxy if we have advice" />
      <item value="Specifies which types are eligible for component scanning. Further narrows the set of candidate components from everything in basePackages() to everything in the base packages that matches the given filter or filters" />
      <item value="Alias for the basePackages() attribute. Allows for more concise annotation declarations e.g.: @EnableJdbcRepositories(&quot;org.my.pkg&quot;) instead of @EnableJdbcRepositories(basePackages=&quot;org.my.pkg&quot;)." />
      <item value="Base packages to scan for annotated components. value() is an alias for (and mutually exclusive with) this attribute. Use basePackageClasses() for a type-safe alternative to String-based package names." />
      <item value="pecifies which types are not eligible for component scanning." />
      <item value="Encapsulates a Java {@link java.lang.reflect.Type}, providing access to {@link getSuperType() supertypes}, {@link getInterfaces() interfaces}, and {@link getGeneric(int...) generic parameters} along with the ability to ultimately {@link resolve() resolve} to a {@link java.lang.Class}. &lt;p&gt;{@code ResolvableTypes} may be obtained from {@link forField(Field) fields}, {@link forMethodParameter(Method, int) method parameters}, {@link forMethodReturnType(Method) method returns} or {@link forClass(Class) classes}. Most methods on this class will themselves return {@link ResolvableType ResolvableTypes}, allowing easy navigation. For example: &lt;pre class=&quot;code&quot;&gt; private HashMap&amp;lt;Integer, List&amp;lt;String&amp;gt;&amp;gt; myMap; public void example() { ResolvableType t = ResolvableType.forField(getClass().getDeclaredField(&quot;myMap&quot;)); t.getSuperType(); AbstractMap&amp;lt;Integer, List&amp;lt;String&amp;gt;&amp;gt; t.asMap(); Map&amp;lt;Integer, List&amp;lt;String&amp;gt;&amp;gt; t.getGeneric(0).resolve(); Integer t.getGeneric(1).resolve(); List t.getGeneric(1); List&amp;lt;String&amp;gt; t.resolveGeneric(1, 0); String } &lt;pre&gt;" />
      <item value="A BeanDefinition describes a bean instance, which has property values, constructor argument values, and further information supplied by concrete implementations. This is just a minimal interface: The main intention is to allow a BeanFactoryPostProcessor to introspect and modify property values and other bean metadata." />
      <item value="Instruments the application startup phase using steps. The core container and its infrastructure components can use the ApplicationStartup to mark steps during the application startup and collect data about the execution context or their processing time." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="46" />
        <entry key="ENGLISH" value="46" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1651587184885" />
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20190412000287251" />
      </app-key>
    </option>
    <option name="phoneticFontFamily" value="Source Code Pro Medium" />
    <option name="primaryFontFamily" value="Microsoft YaHei UI" />
    <option name="translateDocumentation" value="true" />
    <option name="translator" value="YOUDAO" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="3289501515931655" />
      </youdao-translate>
    </option>
  </component>
</application>